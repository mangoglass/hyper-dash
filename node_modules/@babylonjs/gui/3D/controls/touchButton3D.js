// Assumptions: absolute position of button mesh is inside the mesh
import { __extends } from "tslib";
import { Vector3 } from "@babylonjs/core/Maths/math.vector";
import { PointerEventTypes } from "@babylonjs/core/Events/pointerEvents";
import { TmpVectors } from "@babylonjs/core/Maths/math.vector";
import { Button3D } from "./button3D";
/**
 * Class used to create a touchable button in 3D
 */
var TouchButton3D = /** @class */ (function (_super) {
    __extends(TouchButton3D, _super);
    /**
     * Creates a new touchable button
     * @param name defines the control name
     * @param collisionMesh mesh to track collisions with
     */
    function TouchButton3D(name, collisionMesh) {
        var _this = _super.call(this, name) || this;
        _this.collidableFrontDirection = Vector3.Zero();
        if (collisionMesh) {
            _this.collisionMesh = collisionMesh;
        }
        return _this;
    }
    Object.defineProperty(TouchButton3D.prototype, "collidableFrontDirection", {
        /**
         * Returns the front-facing direction of the button, or Vector3.Zero if there is no 'front'
         */
        get: function () {
            if (this._collisionMesh) {
                // Update the front direction to reflect any rotations of the collision mesh
                var transformedDirection = TmpVectors.Vector3[0];
                Vector3.TransformNormalToRef(this._collidableFrontDirection, this._collisionMesh.getWorldMatrix(), transformedDirection);
                return transformedDirection;
            }
            return this._collidableFrontDirection;
        },
        /**
         * Sets the front-facing direction of the button. Pass in Vector3.Zero to allow interactions from any direction
         * @param frontDir the forward direction of the button
         */
        set: function (frontWorldDir) {
            this._collidableFrontDirection = frontWorldDir.normalize();
            if (this._collisionMesh) {
                var invert = TmpVectors.Matrix[0];
                invert.copyFrom(this._collisionMesh.getWorldMatrix());
                invert.invert();
                Vector3.TransformNormalToRef(this._collidableFrontDirection, invert, this._collidableFrontDirection);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TouchButton3D.prototype, "collisionMesh", {
        /**
         * Sets the mesh used for testing input collision
         * @param collisionMesh the new collision mesh for the button
         */
        set: function (collisionMesh) {
            if (this._collisionMesh) {
                this._collisionMesh.dispose();
            }
            // parent the mesh to sync transforms
            if (!collisionMesh.parent && this.mesh) {
                collisionMesh.setParent(this.mesh);
            }
            this._collisionMesh = collisionMesh;
            this._injectGUI3DReservedDataStore(this._collisionMesh).control = this;
            this._collisionMesh.isNearPickable = true;
            this.collidableFrontDirection = collisionMesh.forward;
        },
        enumerable: false,
        configurable: true
    });
    // Returns true if the collidable is in front of the button, or if the button has no front direction
    TouchButton3D.prototype._isInteractionInFrontOfButton = function (collidablePos) {
        var frontDir = this.collidableFrontDirection;
        if (frontDir.length() === 0) {
            // The button has no front, just return the distance to the center
            return true;
        }
        var d = Vector3.Dot(this._collisionMesh.getAbsolutePosition(), frontDir);
        var abc = Vector3.Dot(collidablePos, frontDir);
        return abc > d;
    };
    /** @hidden */
    TouchButton3D.prototype._generatePointerEventType = function (providedType, nearMeshPosition, activeInteractionCount) {
        if (providedType === PointerEventTypes.POINTERDOWN) {
            if (!this._isInteractionInFrontOfButton(nearMeshPosition)) {
                // Near interaction mesh is behind the button, don't send a pointer down
                return PointerEventTypes.POINTERMOVE;
            }
        }
        if (providedType === PointerEventTypes.POINTERUP) {
            if (activeInteractionCount == 0) {
                // We get the release for the down we swallowed earlier, swallow as well
                return PointerEventTypes.POINTERMOVE;
            }
        }
        return providedType;
    };
    TouchButton3D.prototype._getTypeName = function () {
        return "TouchButton3D";
    };
    // Mesh association
    TouchButton3D.prototype._createNode = function (scene) {
        return _super.prototype._createNode.call(this, scene);
    };
    /**
     * Releases all associated resources
     */
    TouchButton3D.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this._collisionMesh) {
            this._collisionMesh.dispose();
        }
    };
    return TouchButton3D;
}(Button3D));
export { TouchButton3D };
//# sourceMappingURL=touchButton3D.js.map