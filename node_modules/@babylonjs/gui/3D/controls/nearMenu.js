import { __extends } from "tslib";
import { TouchHolographicButton } from "./touchHolographicButton";
import { DefaultBehavior } from "../behaviors/defaultBehavior";
import { TouchHolographicMenu } from "./touchHolographicMenu";
/**
 * NearMenu that displays buttons and follows the camera
 */
var NearMenu = /** @class */ (function (_super) {
    __extends(NearMenu, _super);
    /**
     * Creates a near menu GUI 3D control
     * @param name name of the near menu
     */
    function NearMenu(name) {
        var _this = _super.call(this, name) || this;
        _this._isPinned = false;
        _this._defaultBehavior = new DefaultBehavior();
        _this._dragObserver = _this._defaultBehavior.sixDofDragBehavior.onDragObservable.add(function () {
            _this.isPinned = true;
        });
        return _this;
    }
    Object.defineProperty(NearMenu.prototype, "defaultBehavior", {
        /**
         * Regroups all mesh behaviors for the near menu
         */
        get: function () {
            return this._defaultBehavior;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NearMenu.prototype, "isPinned", {
        /**
         * Indicates if the near menu is world-pinned
         */
        get: function () {
            return this._isPinned;
        },
        set: function (value) {
            this._isPinned = value;
            if (this._isPinned) {
                this._pinMaterial.emissiveColor.copyFromFloats(0.25, 0.4, 0.95);
                this._defaultBehavior.followBehaviorEnabled = false;
            }
            else {
                this._pinMaterial.emissiveColor.copyFromFloats(0.08, 0.15, 0.55);
                this._defaultBehavior.followBehaviorEnabled = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    NearMenu.prototype._createPinButton = function (parent) {
        var _this = this;
        var control = new TouchHolographicButton("pin" + this.name, false);
        control.imageUrl = NearMenu.ASSETS_BASE_URL + NearMenu.PIN_ICON_FILENAME;
        control.parent = this;
        control._host = this._host;
        control.onPointerClickObservable.add(function () { return (_this.isPinned = !_this.isPinned); });
        if (this._host.utilityLayer) {
            control._prepareNode(this._host.utilityLayer.utilityLayerScene);
            control.scaling.scaleInPlace(NearMenu.NEAR_BUTTON_SCALE);
            this._pinMaterial = control.backMaterial;
            this._pinMaterial.diffuseColor.copyFromFloats(0, 0, 0);
            if (control.node) {
                control.node.parent = parent;
            }
        }
        return control;
    };
    /**
     * Adds a button to the menu.
     * Please note that the back material of the button will be set to transparent as it is attached to the menu.
     *
     * @param button Button to add
     * @returns This menu
     */
    NearMenu.prototype.addButton = function (button) {
        // Block updating the layout until the button is resized (which has to happen after node creation)
        var wasLayoutBlocked = this.blockLayout;
        if (!wasLayoutBlocked) {
            this.blockLayout = true;
        }
        _super.prototype.addButton.call(this, button);
        button.scaling.scaleInPlace(NearMenu.NEAR_BUTTON_SCALE);
        // Unblocking the layout triggers the pending layout update that uses the size of the buttons to determine the size of the backing mesh
        if (!wasLayoutBlocked) {
            this.blockLayout = false;
        }
        return this;
    };
    NearMenu.prototype._createNode = function (scene) {
        var node = _super.prototype._createNode.call(this, scene);
        this._pinButton = this._createPinButton(node);
        this.isPinned = false;
        this._defaultBehavior.attach(node, [this._backPlate]);
        this._defaultBehavior.followBehavior.ignoreCameraPitchAndRoll = true;
        this._defaultBehavior.followBehavior.pitchOffset = -15;
        this._defaultBehavior.followBehavior.minimumDistance = 0.3;
        this._defaultBehavior.followBehavior.defaultDistance = 0.4;
        this._defaultBehavior.followBehavior.maximumDistance = 0.6;
        this._backPlate.isNearGrabbable = true;
        node.isVisible = false;
        return node;
    };
    NearMenu.prototype._finalProcessing = function () {
        _super.prototype._finalProcessing.call(this);
        this._pinButton.position.copyFromFloats(this._backPlate.scaling.x / 2 + 0.02, this._backPlate.scaling.y / 2, -0.01);
    };
    /**
     * Disposes the near menu
     */
    NearMenu.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._defaultBehavior.sixDofDragBehavior.onDragObservable.remove(this._dragObserver);
        this._defaultBehavior.detach();
    };
    /**
     * Base Url for the assets.
     */
    NearMenu.ASSETS_BASE_URL = "https://assets.babylonjs.com/meshes/MRTK/";
    /**
     * File name for the close icon.
     */
    NearMenu.PIN_ICON_FILENAME = "IconPin.png";
    /**
     * Scale for the buttons added to the near menu
     */
    NearMenu.NEAR_BUTTON_SCALE = 0.32;
    return NearMenu;
}(TouchHolographicMenu));
export { NearMenu };
//# sourceMappingURL=nearMenu.js.map