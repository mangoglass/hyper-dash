{"version":3,"file":"touchHolographicMenu.js","sourceRoot":"","sources":["../../../../sourceES6/gui/src/3D/controls/touchHolographicMenu.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"@babylonjs/core/scene\";\r\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\r\nimport { Nullable } from \"@babylonjs/core/types\";\r\nimport { Control3D } from \"./control3D\";\r\nimport { VolumeBasedPanel } from \"./volumeBasedPanel\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { BoxBuilder } from \"@babylonjs/core/Meshes/Builders/boxBuilder\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { FluentMaterial } from \"../materials/fluent/fluentMaterial\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { Observer } from \"@babylonjs/core/Misc/observable\";\r\nimport { Logger } from \"@babylonjs/core/Misc/logger\";\r\nimport { Container3D } from \"./container3D\";\r\nimport { TouchHolographicButton } from \"./touchHolographicButton\";\r\n\r\n/**\r\n * Simple menu that can contain holographic buttons\r\n */\r\nexport class TouchHolographicMenu extends VolumeBasedPanel {\r\n    protected _backPlate: Mesh;\r\n    private _backPlateMaterial: FluentMaterial;\r\n    private _pickedPointObserver: Nullable<Observer<Nullable<Vector3>>>;\r\n\r\n    private _currentMin: Nullable<Vector3>;\r\n    private _currentMax: Nullable<Vector3>;\r\n\r\n    /**\r\n     * Margin size of the backplate in button size units (setting this to 1, will make the backPlate margin the size of 1 button)\r\n     */\r\n    public backPlateMargin = 1.25;\r\n\r\n    protected _createNode(scene: Scene): Nullable<TransformNode> {\r\n        const node = new Mesh(`menu_${this.name}`, scene);\r\n\r\n        this._backPlate = BoxBuilder.CreateBox(\"backPlate\" + this.name, { size: 1 }, scene);\r\n        this._backPlate.parent = node;\r\n\r\n        return node;\r\n    }\r\n\r\n    protected _affectMaterial(mesh: AbstractMesh) {\r\n        this._backPlateMaterial = new FluentMaterial(this.name + \"backPlateMaterial\", mesh.getScene());\r\n        this._backPlateMaterial.albedoColor = new Color3(0.08, 0.15, 0.55);\r\n        this._backPlateMaterial.renderBorders = true;\r\n        this._backPlateMaterial.renderHoverLight = true;\r\n\r\n        this._pickedPointObserver = this._host.onPickedPointChangedObservable.add((pickedPoint) => {\r\n            if (pickedPoint) {\r\n                this._backPlateMaterial.hoverPosition = pickedPoint;\r\n                this._backPlateMaterial.hoverColor.a = 1.0;\r\n            } else {\r\n                this._backPlateMaterial.hoverColor.a = 0;\r\n            }\r\n        });\r\n\r\n        this._backPlate.material = this._backPlateMaterial;\r\n    }\r\n\r\n    protected _mapGridNode(control: Control3D, nodePosition: Vector3) {\r\n        // Simple plane mapping for the menu\r\n        const mesh = control.mesh;\r\n\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        control.position = nodePosition.clone();\r\n\r\n        if (!this._currentMin) {\r\n            this._currentMin = nodePosition.clone();\r\n            this._currentMax = nodePosition.clone();\r\n        }\r\n\r\n        this._currentMin.minimizeInPlace(nodePosition);\r\n        this._currentMax!.maximizeInPlace(nodePosition);\r\n    }\r\n\r\n    protected _finalProcessing() {\r\n        this._currentMin!.addInPlaceFromFloats(-this._cellWidth / 2, -this._cellHeight / 2, 0);\r\n        this._currentMax!.addInPlaceFromFloats(this._cellWidth / 2, this._cellHeight / 2, 0);\r\n        const extendSize = this._currentMax!.subtract(this._currentMin!);\r\n\r\n        // Also add a % margin\r\n        this._backPlate.scaling.x = extendSize.x + this._cellWidth * this.backPlateMargin;\r\n        this._backPlate.scaling.y = extendSize.y + this._cellHeight * this.backPlateMargin;\r\n        this._backPlate.scaling.z = 0.001;\r\n\r\n        for (let i = 0; i < this._children.length; i++) {\r\n            this._children[i].position.subtractInPlace(this._currentMin!).subtractInPlace(extendSize.scale(0.5));\r\n            this._children[i].position.z -= 0.01;\r\n        }\r\n\r\n        this._currentMin = null;\r\n        this._currentMax = null;\r\n    }\r\n\r\n    /**\r\n     * Creates a holographic menu GUI 3D control\r\n     * @param name name of the menu\r\n     */\r\n    constructor(name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Adds a button to the menu.\r\n     * Please note that the back material of the button will be set to transparent as it is attached to the menu.\r\n     *\r\n     * @param button Button to add\r\n     * @returns This menu\r\n     */\r\n    public addButton(button: TouchHolographicButton): TouchHolographicMenu {\r\n        super.addControl(button);\r\n\r\n        if (button.backMaterial) {\r\n            button.backMaterial.alpha = 0;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * This method should not be used directly. It is inherited from `Container3D`.\r\n     * Please use `addButton` instead.\r\n     * @param _control\r\n     * @returns\r\n     */\r\n    public addControl(_control: Control3D): Container3D {\r\n        Logger.Warn(\"TouchHolographicMenu can only contain buttons. Please use the method `addButton` instead.\");\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes the menu\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);\r\n    }\r\n}\r\n"]}