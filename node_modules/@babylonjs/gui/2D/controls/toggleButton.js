import { __extends } from "tslib";
import { Observable } from "@babylonjs/core/Misc/observable";
import { Rectangle } from "./rectangle";
import { _TypeStore } from "@babylonjs/core/Misc/typeStore";
/**
 * Class used to create toggle buttons
 */
var ToggleButton = /** @class */ (function (_super) {
    __extends(ToggleButton, _super);
    /**
     * Creates a new ToggleButton
     * @param name defines the control name
     * @param group defines the toggle group this toggle belongs to
     */
    function ToggleButton(name, group) {
        var _this = _super.call(this, name) || this;
        _this.name = name;
        /** Observable raised when isActive is changed */
        _this.onIsActiveChangedObservable = new Observable();
        /**
         * Gets or sets a boolean indicating that the toggle button will let internal controls handle picking instead of doing it directly using its bounding info
         */
        _this.delegatePickingToChildren = false;
        _this._isActive = false;
        _this.group = group !== null && group !== void 0 ? group : "";
        _this.thickness = 0;
        _this.isPointerBlocker = true;
        var alphaStore = null;
        _this.toActiveAnimation = function () {
            _this.thickness = 1;
        };
        _this.toInactiveAnimation = function () {
            _this.thickness = 0;
        };
        _this.pointerEnterActiveAnimation = function () {
            alphaStore = _this.alpha;
            _this.alpha -= 0.1;
        };
        _this.pointerOutActiveAnimation = function () {
            if (alphaStore !== null) {
                _this.alpha = alphaStore;
            }
        };
        _this.pointerDownActiveAnimation = function () {
            _this.scaleX -= 0.05;
            _this.scaleY -= 0.05;
        };
        _this.pointerUpActiveAnimation = function () {
            _this.scaleX += 0.05;
            _this.scaleY += 0.05;
        };
        _this.pointerEnterInactiveAnimation = function () {
            alphaStore = _this.alpha;
            _this.alpha -= 0.1;
        };
        _this.pointerOutInactiveAnimation = function () {
            if (alphaStore !== null) {
                _this.alpha = alphaStore;
            }
        };
        _this.pointerDownInactiveAnimation = function () {
            _this.scaleX -= 0.05;
            _this.scaleY -= 0.05;
        };
        _this.pointerUpInactiveAnimation = function () {
            _this.scaleX += 0.05;
            _this.scaleY += 0.05;
        };
        return _this;
    }
    Object.defineProperty(ToggleButton.prototype, "image", {
        /**
         * Returns the ToggleButton's image control if it exists
         */
        get: function () {
            return this._image;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ToggleButton.prototype, "textBlock", {
        /**
         * Returns the ToggleButton's child TextBlock control if it exists
         */
        get: function () {
            return this._textBlock;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ToggleButton.prototype, "group", {
        /** Gets or sets group name this toggle button belongs to */
        get: function () {
            return this._group;
        },
        set: function (value) {
            if (this._group === value) {
                return;
            }
            this._group = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ToggleButton.prototype, "isActive", {
        /** Gets or sets a boolean indicating if the toogle button is active or not */
        get: function () {
            return this._isActive;
        },
        set: function (value) {
            var _this = this;
            var _a, _b;
            // Function modeled after radioButton.ts
            if (this._isActive === value) {
                return;
            }
            this._isActive = value;
            // Update the visual state based on the new value
            if (this._isActive) {
                (_a = this.toActiveAnimation) === null || _a === void 0 ? void 0 : _a.call(this);
            }
            else {
                (_b = this.toInactiveAnimation) === null || _b === void 0 ? void 0 : _b.call(this);
            }
            this._markAsDirty();
            this.onIsActiveChangedObservable.notifyObservers(value);
            if (this._isActive && this._host && this._group) {
                // A toggle button in a group can only have 1 active element at a given time.
                // If this toggle button has a group, set other toggle buttons in the group to inactive.
                this._host.executeOnAllControls(function (control) {
                    // Check for control type ToggleButton
                    if (control.typeName === "ToggleButton") {
                        // Don't do anything to this toggle button
                        if (control === _this) {
                            return;
                        }
                        var childToggle = control;
                        // If toggle button is in same group, set isActive to false
                        if (childToggle.group === _this.group) {
                            childToggle.isActive = false;
                        }
                    }
                });
            }
        },
        enumerable: false,
        configurable: true
    });
    ToggleButton.prototype._getTypeName = function () {
        return "ToggleButton";
    };
    // While being a container, the toggle button behaves like a control.
    /** @hidden */
    ToggleButton.prototype._processPicking = function (x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY) {
        if (!this._isEnabled || !this.isHitTestVisible || !this.isVisible || this.notRenderable) {
            return false;
        }
        if (!_super.prototype.contains.call(this, x, y)) {
            return false;
        }
        if (this.delegatePickingToChildren) {
            var contains = false;
            for (var index = this._children.length - 1; index >= 0; index--) {
                var child = this._children[index];
                if (child.isEnabled && child.isHitTestVisible && child.isVisible && !child.notRenderable && child.contains(x, y)) {
                    contains = true;
                    break;
                }
            }
            if (!contains) {
                return false;
            }
        }
        this._processObservables(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY);
        return true;
    };
    /** @hidden */
    ToggleButton.prototype._onPointerEnter = function (target, pi) {
        if (!_super.prototype._onPointerEnter.call(this, target, pi)) {
            return false;
        }
        if (this._isActive) {
            if (this.pointerEnterActiveAnimation) {
                this.pointerEnterActiveAnimation();
            }
        }
        else {
            if (this.pointerEnterInactiveAnimation) {
                this.pointerEnterInactiveAnimation();
            }
        }
        return true;
    };
    /** @hidden */
    ToggleButton.prototype._onPointerOut = function (target, pi, force) {
        if (force === void 0) { force = false; }
        if (this._isActive) {
            if (this.pointerOutActiveAnimation) {
                this.pointerOutActiveAnimation();
            }
        }
        else {
            if (this.pointerOutInactiveAnimation) {
                this.pointerOutInactiveAnimation();
            }
        }
        _super.prototype._onPointerOut.call(this, target, pi, force);
    };
    /** @hidden */
    ToggleButton.prototype._onPointerDown = function (target, coordinates, pointerId, buttonIndex, pi) {
        if (!_super.prototype._onPointerDown.call(this, target, coordinates, pointerId, buttonIndex, pi)) {
            return false;
        }
        if (this._isActive) {
            if (this.pointerDownActiveAnimation) {
                this.pointerDownActiveAnimation();
            }
        }
        else {
            if (this.pointerDownInactiveAnimation) {
                this.pointerDownInactiveAnimation();
            }
        }
        return true;
    };
    /** @hidden */
    ToggleButton.prototype._onPointerUp = function (target, coordinates, pointerId, buttonIndex, notifyClick, pi) {
        if (this._isActive) {
            if (this.pointerUpActiveAnimation) {
                this.pointerUpActiveAnimation();
            }
        }
        else {
            if (this.pointerUpInactiveAnimation) {
                this.pointerUpInactiveAnimation();
            }
        }
        _super.prototype._onPointerUp.call(this, target, coordinates, pointerId, buttonIndex, notifyClick, pi);
    };
    return ToggleButton;
}(Rectangle));
export { ToggleButton };
_TypeStore.RegisteredTypes["BABYLON.GUI.ToggleButton"] = ToggleButton;
//# sourceMappingURL=toggleButton.js.map