{"version":3,"file":"handConstraintBehavior.js","sourceRoot":"","sources":["../../../../sourceES6/core/Behaviors/Meshes/handConstraintBehavior.ts"],"names":[],"mappings":"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","sourcesContent":["import { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName } from \"../../XR/webXRFeaturesManager\";\r\nimport { WebXRHandTracking, XRHandJoint } from \"../../XR/features/WebXRHandTracking\";\r\nimport { WebXRExperienceHelper } from \"../../XR/webXRExperienceHelper\";\r\nimport { Behavior } from \"../behavior\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\n\r\n/**\r\n * Zones around the hand\r\n */\r\nexport enum HandConstraintZone {\r\n    /**\r\n     * Above finger tips\r\n     */\r\n    ABOVE_FINGER_TIPS,\r\n    /**\r\n     * Next to the thumb\r\n     */\r\n    RADIAL_SIDE,\r\n    /**\r\n     * Next to the pinky finger\r\n     */\r\n    ULNAR_SIDE,\r\n    /**\r\n     * Below the wrist\r\n     */\r\n    BELOW_WRIST,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport enum HandConstraintOrientation {\r\n    /**\r\n     * Orientation is towards the camera\r\n     */\r\n    LOOK_AT_CAMERA,\r\n    /**\r\n     * Orientation is determined by the rotation of the palm\r\n     */\r\n    HAND_ROTATION,\r\n}\r\n\r\n/**\r\n * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.\r\n */\r\nexport class HandConstraintBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n    private _node: TransformNode;\r\n    private _handTracking: Nullable<WebXRHandTracking>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _zoneAxis: { [id: number]: Vector3 } = {};\r\n\r\n    /**\r\n     * Offset distance from the hand in meters\r\n     */\r\n    public targetOffset: number = 0.1;\r\n\r\n    /**\r\n     * Where to place the node regarding the center of the hand.\r\n     */\r\n    public targetZone: HandConstraintZone = HandConstraintZone.RADIAL_SIDE;\r\n\r\n    /**\r\n     * Orientation mode of the 4 zones around the hand\r\n     */\r\n    public zoneOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n    /**\r\n     * Orientation mode of the node attached to this behavior\r\n     */\r\n    public nodeOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n\r\n    /**\r\n     * Set the hand this behavior should follow. If set to \"none\", it will follow any visible hand (prioritising the right one).\r\n     */\r\n    public handedness: XRHandedness = \"right\";\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 100;\r\n\r\n    /**\r\n     * Builds a hand constraint behavior\r\n     */\r\n    constructor() {\r\n        // For a right hand\r\n        this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);\r\n        this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(-1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);\r\n    }\r\n\r\n    /** gets or sets behavior's name */\r\n    public get name() {\r\n        return \"HandConstraint\";\r\n    }\r\n\r\n    private _getHandPose() {\r\n        if (!this._handTracking) {\r\n            return null;\r\n        }\r\n\r\n        // Retrieve any available hand, starting by the right\r\n        let hand;\r\n        if (this.handedness === \"none\") {\r\n            hand = this._handTracking.getHandByHandedness(\"right\") || this._handTracking.getHandByHandedness(\"left\");\r\n        } else {\r\n            hand = this._handTracking.getHandByHandedness(this.handedness);\r\n        }\r\n\r\n        if (hand) {\r\n            const pinkyMetacarpal = hand.getJointMesh(XRHandJoint.PINKY_FINGER_METACARPAL);\r\n            const middleMetacarpal = hand.getJointMesh(XRHandJoint.MIDDLE_FINGER_METACARPAL);\r\n            const wrist = hand.getJointMesh(XRHandJoint.WRIST);\r\n\r\n            if (wrist && middleMetacarpal && pinkyMetacarpal) {\r\n                // palm forward\r\n                const up = TmpVectors.Vector3[0];\r\n                up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();\r\n                const forward = TmpVectors.Vector3[1];\r\n                pinkyMetacarpal.absolutePosition.subtractToRef(middleMetacarpal.absolutePosition, forward);\r\n                forward.normalize();\r\n                Vector3.CrossToRef(forward, up, forward);\r\n\r\n                const left = TmpVectors.Vector3[2];\r\n                Vector3.CrossToRef(forward, up, left);\r\n\r\n                const quaternion = Quaternion.FromLookDirectionLH(forward, up);\r\n\r\n                return {\r\n                    quaternion,\r\n                    position: middleMetacarpal.absolutePosition,\r\n                    controllerId: hand.xrController.uniqueId\r\n                };\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Initializes the hand constraint behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the hand constraint to a `TransformNode`\r\n     * @param node defines the node to attach the behavior to\r\n     */\r\n    public attach(node: TransformNode): void {\r\n        this._node = node;\r\n        this._scene = node.getScene();\r\n\r\n        if (!this._node.rotationQuaternion) {\r\n            this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);\r\n        }\r\n\r\n        let lastTick = Date.now();\r\n        this._scene.onBeforeRenderObservable.add(() => {\r\n            const pose = this._getHandPose();\r\n\r\n            this._node.reservedDataStore = this._node.reservedDataStore || {};\r\n            this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};\r\n            this._node.reservedDataStore.nearInteraction.excludedControllerId = null;\r\n\r\n            if (pose) {\r\n                const zoneOffset = TmpVectors.Vector3[0];\r\n                const camera = this._scene.activeCamera;\r\n\r\n                zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);\r\n\r\n                const cameraLookAtQuaternion = TmpVectors.Quaternion[0];\r\n                if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {\r\n                    const toCamera = TmpVectors.Vector3[1];\r\n                    toCamera.copyFrom(camera.position);\r\n                    toCamera.subtractInPlace(pose.position).normalize();\r\n                    if (this._scene.useRightHandedSystem) {\r\n                        Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    } else {\r\n                        Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    }\r\n                }\r\n\r\n                if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                } else {\r\n                    cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                }\r\n\r\n                Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);\r\n                zoneOffset.scaleInPlace(this.targetOffset);\r\n\r\n                const targetPosition = TmpVectors.Vector3[2];\r\n                const targetRotation = TmpVectors.Quaternion[1];\r\n                targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);\r\n\r\n                if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    targetRotation.copyFrom(pose.quaternion);\r\n                } else {\r\n                    targetRotation.copyFrom(cameraLookAtQuaternion);\r\n                }\r\n\r\n                const elapsed = Date.now() - lastTick;\r\n\r\n                Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);\r\n                Quaternion.SmoothToRef(this._node.rotationQuaternion!, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion!);\r\n\r\n                this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.controllerId;\r\n            }\r\n\r\n            lastTick = Date.now();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from the `TransformNode`\r\n     */\r\n    public detach(): void {\r\n        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n    }\r\n\r\n    /**\r\n     * Links the behavior to the XR experience in which to retrieve hand transform information.\r\n     * @param xr xr experience\r\n     */\r\n    public linkToXRExperience(xr: WebXRExperienceHelper) {\r\n        this._handTracking = xr.featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING) as WebXRHandTracking;\r\n    }\r\n}\r\n"]}