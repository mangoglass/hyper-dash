import { Texture } from "../Materials/Textures/texture";
import { RenderTargetTexture } from "../Materials/Textures/renderTargetTexture";
import { PassPostProcess } from "../PostProcesses/passPostProcess";
import { PostProcess } from '../PostProcesses/postProcess';
/**
 * Class used to host texture specific utilities
 */
var TextureTools = /** @class */ (function () {
    function TextureTools() {
    }
    /**
     * Uses the GPU to create a copy texture rescaled at a given size
     * @param texture Texture to copy from
     * @param width defines the desired width
     * @param height defines the desired height
     * @param useBilinearMode defines if bilinear mode has to be used
     * @return the generated texture
     */
    TextureTools.CreateResizedCopy = function (texture, width, height, useBilinearMode) {
        if (useBilinearMode === void 0) { useBilinearMode = true; }
        var scene = texture.getScene();
        var engine = scene.getEngine();
        var rtt = new RenderTargetTexture('resized' + texture.name, { width: width, height: height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
        rtt.wrapU = texture.wrapU;
        rtt.wrapV = texture.wrapV;
        rtt.uOffset = texture.uOffset;
        rtt.vOffset = texture.vOffset;
        rtt.uScale = texture.uScale;
        rtt.vScale = texture.vScale;
        rtt.uAng = texture.uAng;
        rtt.vAng = texture.vAng;
        rtt.wAng = texture.wAng;
        rtt.coordinatesIndex = texture.coordinatesIndex;
        rtt.level = texture.level;
        rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
        rtt._texture.isReady = false;
        texture.wrapU = Texture.CLAMP_ADDRESSMODE;
        texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        var passPostProcess = new PassPostProcess("pass", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);
        passPostProcess.getEffect().executeWhenCompiled(function () {
            passPostProcess.onApply = function (effect) {
                effect.setTexture("textureSampler", texture);
            };
            var internalTexture = rtt.getInternalTexture();
            if (internalTexture) {
                scene.postProcessManager.directRender([passPostProcess], internalTexture);
                engine.unBindFramebuffer(internalTexture);
                rtt.disposeFramebufferObjects();
                passPostProcess.dispose();
                internalTexture.isReady = true;
            }
        });
        return rtt;
    };
    /**
     * Apply a post process to a texture
     * @param postProcessName name of the fragment post process
     * @param internalTexture the texture to encode
     * @param scene the scene hosting the texture
     * @param type type of the output texture. If not provided, use the one from internalTexture
     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture
     * @param format format of the output texture. If not provided, use the one from internalTexture
     * @return a promise with the internalTexture having its texture replaced by the result of the processing
     */
    TextureTools.ApplyPostProcess = function (postProcessName, internalTexture, scene, type, samplingMode, format) {
        // Gets everything ready.
        var engine = internalTexture.getEngine();
        internalTexture.isReady = false;
        samplingMode = samplingMode !== null && samplingMode !== void 0 ? samplingMode : internalTexture.samplingMode;
        type = type !== null && type !== void 0 ? type : internalTexture.type;
        format = format !== null && format !== void 0 ? format : internalTexture.format;
        if (type === -1) {
            type = 0;
        }
        return new Promise(function (resolve) {
            // Create the post process
            var postProcess = new PostProcess("postprocess", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);
            // Hold the output of the decoding.
            var encodedTexture = engine.createRenderTargetTexture({ width: internalTexture.width, height: internalTexture.height }, {
                generateDepthBuffer: false,
                generateMipMaps: false,
                generateStencilBuffer: false,
                samplingMode: samplingMode,
                type: type,
                format: format
            });
            postProcess.getEffect().executeWhenCompiled(function () {
                // PP Render Pass
                postProcess.onApply = function (effect) {
                    effect._bindTexture("textureSampler", internalTexture);
                    effect.setFloat2("scale", 1, 1);
                };
                scene.postProcessManager.directRender([postProcess], encodedTexture, true);
                // Cleanup
                engine.restoreDefaultFramebuffer();
                engine._releaseTexture(internalTexture);
                engine._releaseFramebufferObjects(encodedTexture);
                if (postProcess) {
                    postProcess.dispose();
                }
                // Internal Swap
                encodedTexture._swapAndDie(internalTexture);
                // Ready to get rolling again.
                internalTexture.type = type;
                internalTexture.format = 5;
                internalTexture.isReady = true;
                resolve(internalTexture);
            });
        });
    };
    return TextureTools;
}());
export { TextureTools };
//# sourceMappingURL=textureTools.js.map