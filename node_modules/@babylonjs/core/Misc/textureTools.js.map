{"version":3,"file":"textureTools.js","sourceRoot":"","sources":["../../../sourceES6/core/Misc/textureTools.ts"],"names":[],"mappings":"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","sourcesContent":["import { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\n\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from '../PostProcesses/postProcess';\r\nimport { Engine } from '../Engines/engine';\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport class TextureTools {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @return the generated texture\r\n     */\r\n    public static CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n\r\n        var scene = <Scene>texture.getScene();\r\n        var engine = scene.getEngine();\r\n\r\n        let rtt = new RenderTargetTexture(\r\n            'resized' + texture.name,\r\n            { width: width, height: height },\r\n            scene,\r\n            !texture.noMipmap,\r\n            true,\r\n            (<InternalTexture>texture._texture).type,\r\n            false,\r\n            texture.samplingMode,\r\n            false\r\n        );\r\n\r\n        rtt.wrapU = texture.wrapU;\r\n        rtt.wrapV = texture.wrapV;\r\n        rtt.uOffset = texture.uOffset;\r\n        rtt.vOffset = texture.vOffset;\r\n        rtt.uScale = texture.uScale;\r\n        rtt.vScale = texture.vScale;\r\n        rtt.uAng = texture.uAng;\r\n        rtt.vAng = texture.vAng;\r\n        rtt.wAng = texture.wAng;\r\n        rtt.coordinatesIndex = texture.coordinatesIndex;\r\n        rtt.level = texture.level;\r\n        rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n        (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        let passPostProcess = new PassPostProcess(\"pass\", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);\r\n        passPostProcess.getEffect().executeWhenCompiled(() => {\r\n            passPostProcess.onApply = function(effect) {\r\n                effect.setTexture(\"textureSampler\", texture);\r\n            };\r\n\r\n            let internalTexture = rtt.getInternalTexture();\r\n\r\n            if (internalTexture) {\r\n                scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n                engine.unBindFramebuffer(internalTexture);\r\n                rtt.disposeFramebufferObjects();\r\n                passPostProcess.dispose();\r\n\r\n                internalTexture.isReady = true;\r\n            }\r\n        });\r\n\r\n        return rtt;\r\n    }\r\n\r\n    /**\r\n     * Apply a post process to a texture\r\n     * @param postProcessName name of the fragment post process\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param type type of the output texture. If not provided, use the one from internalTexture\r\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n     * @param format format of the output texture. If not provided, use the one from internalTexture\r\n     * @return a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    public static ApplyPostProcess(postProcessName: string, internalTexture: InternalTexture, scene: Scene, type?: number, samplingMode?: number, format?: number): Promise<InternalTexture> {\r\n        // Gets everything ready.\r\n        const engine = internalTexture.getEngine() as Engine;\r\n\r\n        internalTexture.isReady = false;\r\n\r\n        samplingMode = samplingMode ?? internalTexture.samplingMode;\r\n        type = type ?? internalTexture.type;\r\n        format = format ?? internalTexture.format;\r\n\r\n        if (type === -1) {\r\n            type = 0;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            // Create the post process\r\n            const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine,\r\n                false, undefined, type, undefined, null, false, format);\r\n\r\n            // Hold the output of the decoding.\r\n            const encodedTexture = engine.createRenderTargetTexture({ width: internalTexture.width, height: internalTexture.height }, {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode,\r\n                type,\r\n                format\r\n            });\r\n\r\n            postProcess.getEffect().executeWhenCompiled(() => {\r\n                // PP Render Pass\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", internalTexture);\r\n                    effect.setFloat2(\"scale\", 1, 1);\r\n                };\r\n                scene.postProcessManager.directRender([postProcess!], encodedTexture, true);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                engine._releaseTexture(internalTexture);\r\n                engine._releaseFramebufferObjects(encodedTexture);\r\n                if (postProcess) {\r\n                    postProcess.dispose();\r\n                }\r\n\r\n                // Internal Swap\r\n                encodedTexture._swapAndDie(internalTexture);\r\n\r\n                // Ready to get rolling again.\r\n                internalTexture.type = type!;\r\n                internalTexture.format = 5;\r\n                internalTexture.isReady = true;\r\n\r\n                resolve(internalTexture);\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n"]}