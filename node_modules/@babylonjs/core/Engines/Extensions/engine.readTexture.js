import { ThinEngine } from "../../Engines/thinEngine";
ThinEngine.prototype._readTexturePixelsSync = function (texture, width, height, faceIndex, level, buffer, flushRenderer) {
    var _a, _b;
    if (faceIndex === void 0) { faceIndex = -1; }
    if (level === void 0) { level = 0; }
    if (buffer === void 0) { buffer = null; }
    if (flushRenderer === void 0) { flushRenderer = true; }
    var gl = this._gl;
    if (!gl) {
        throw new Error("Engine does not have gl rendering context.");
    }
    if (!this._dummyFramebuffer) {
        var dummy = gl.createFramebuffer();
        if (!dummy) {
            throw new Error("Unable to create dummy framebuffer");
        }
        this._dummyFramebuffer = dummy;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);
    if (faceIndex > -1) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, level);
    }
    else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, (_b = texture._hardwareTexture) === null || _b === void 0 ? void 0 : _b.underlyingResource, level);
    }
    var readType = (texture.type !== undefined) ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;
    switch (readType) {
        case gl.UNSIGNED_BYTE:
            if (!buffer) {
                buffer = new Uint8Array(4 * width * height);
            }
            readType = gl.UNSIGNED_BYTE;
            break;
        default:
            if (!buffer) {
                buffer = new Float32Array(4 * width * height);
            }
            readType = gl.FLOAT;
            break;
    }
    if (flushRenderer) {
        this.flushFramebuffer();
    }
    gl.readPixels(0, 0, width, height, gl.RGBA, readType, buffer);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);
    return buffer;
};
ThinEngine.prototype._readTexturePixels = function (texture, width, height, faceIndex, level, buffer, flushRenderer) {
    if (faceIndex === void 0) { faceIndex = -1; }
    if (level === void 0) { level = 0; }
    if (buffer === void 0) { buffer = null; }
    if (flushRenderer === void 0) { flushRenderer = true; }
    return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer));
};
//# sourceMappingURL=engine.readTexture.js.map