import * as WebGPUConstants from './webgpuConstants';
import { Logger } from '../../Misc/logger';
var _knownUBOs = {
    "Scene": { setIndex: 0, bindingIndex: 0 },
    "Light0": { setIndex: 0, bindingIndex: 5 },
    "Light1": { setIndex: 0, bindingIndex: 6 },
    "Light2": { setIndex: 0, bindingIndex: 7 },
    "Light3": { setIndex: 0, bindingIndex: 8 },
    "Light4": { setIndex: 0, bindingIndex: 9 },
    "Light5": { setIndex: 0, bindingIndex: 10 },
    "Light6": { setIndex: 0, bindingIndex: 11 },
    "Light7": { setIndex: 0, bindingIndex: 12 },
    "Light8": { setIndex: 0, bindingIndex: 13 },
    "Material": { setIndex: 1, bindingIndex: 0 },
    "Mesh": { setIndex: 1, bindingIndex: 1 },
};
var _knownSamplers = {
    "environmentBrdfSampler": { sampler: { setIndex: 0, bindingIndex: 1 }, isTextureArray: false, textures: [{ setIndex: 0, bindingIndex: 2 }] },
    // "reflectionSampler": { setIndex: 0, bindingIndex: 3 },
};
// TODO WEBGPU. sampler3D
var _samplerFunctionByWebGLSamplerType = {
    "sampler2D": "sampler2D",
    "sampler2DArray": "sampler2DArray",
    "sampler2DShadow": "sampler2DShadow",
    "sampler2DArrayShadow": "sampler2DArrayShadow",
    "samplerCube": "samplerCube"
};
var _textureTypeByWebGLSamplerType = {
    "sampler2D": "texture2D",
    "sampler2DArray": "texture2DArray",
    "sampler2DShadow": "texture2D",
    "sampler2DArrayShadow": "texture2DArray",
    "samplerCube": "textureCube",
    "samplerCubeArray": "textureCubeArray"
};
var _gpuTextureViewDimensionByWebGPUTextureType = {
    "textureCube": WebGPUConstants.TextureViewDimension.Cube,
    "textureCubeArray": WebGPUConstants.TextureViewDimension.CubeArray,
    "texture2D": WebGPUConstants.TextureViewDimension.E2d,
    "texture2DArray": WebGPUConstants.TextureViewDimension.E2dArray,
};
// if the webgl sampler type is not listed in this array, "sampler" is taken by default
var _samplerTypeByWebGLSamplerType = {
    "sampler2DShadow": "samplerShadow",
    "sampler2DArrayShadow": "samplerShadow",
};
var _isComparisonSamplerByWebGPUSamplerType = {
    "samplerShadow": true,
    "samplerArrayShadow": true,
    "sampler": false,
};
/** @hidden */
var WebGPUShaderProcessor = /** @class */ (function () {
    function WebGPUShaderProcessor() {
        this._missingVaryings = [];
        this._textureArrayProcessing = [];
    }
    WebGPUShaderProcessor.prototype._getArraySize = function (name, preProcessors) {
        var length = 0;
        var startArray = name.indexOf("[");
        var endArray = name.indexOf("]");
        if (startArray > 0 && endArray > 0) {
            var lengthInString = name.substring(startArray + 1, endArray);
            length = +(lengthInString);
            if (isNaN(length)) {
                length = +(preProcessors[lengthInString.trim()]);
            }
            name = name.substr(0, startArray);
        }
        return [name, length];
    };
    WebGPUShaderProcessor.prototype.initializeShaders = function (processingContext) {
        this._missingVaryings.length = 0;
        this._textureArrayProcessing.length = 0;
    };
    WebGPUShaderProcessor.prototype.varyingProcessor = function (varying, isFragment, preProcessors, processingContext) {
        this._preProcessors = preProcessors;
        var webgpuProcessingContext = processingContext;
        var varyingRegex = new RegExp(/\s*varying\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm);
        var match = varyingRegex.exec(varying);
        if (match != null) {
            var varyingType = match[1];
            var name_1 = match[2];
            var location_1;
            if (isFragment) {
                location_1 = webgpuProcessingContext.availableVaryings[name_1];
                this._missingVaryings[location_1] = "";
                if (location_1 === undefined) {
                    Logger.Warn("Invalid fragment shader: The varying named \"" + name_1 + "\" is not declared in the vertex shader! This declaration will be ignored.");
                }
            }
            else {
                location_1 = webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name_1, preProcessors)[1]);
                webgpuProcessingContext.availableVaryings[name_1] = location_1;
                this._missingVaryings[location_1] = "layout(location = " + location_1 + ") in " + varyingType + " " + name_1 + ";";
            }
            varying = varying.replace(match[0], location_1 === undefined ? "" : "layout(location = " + location_1 + ") " + (isFragment ? "in" : "out") + " " + varyingType + " " + name_1 + ";");
        }
        return varying;
    };
    WebGPUShaderProcessor.prototype.attributeProcessor = function (attribute, preProcessors, processingContext) {
        this._preProcessors = preProcessors;
        var webgpuProcessingContext = processingContext;
        var attribRegex = new RegExp(/\s*attribute\s+(\S+)\s+(\S+)\s*;/gm);
        var match = attribRegex.exec(attribute);
        if (match != null) {
            var varyingType = match[1];
            var name_2 = match[2];
            var location_2 = webgpuProcessingContext.getAttributeNextLocation(varyingType, this._getArraySize(name_2, preProcessors)[1]);
            webgpuProcessingContext.availableAttributes[name_2] = location_2;
            webgpuProcessingContext.orderedAttributes[location_2] = name_2;
            attribute = attribute.replace(match[0], "layout(location = " + location_2 + ") in " + varyingType + " " + name_2 + ";");
        }
        return attribute;
    };
    WebGPUShaderProcessor.prototype.uniformProcessor = function (uniform, isFragment, preProcessors, processingContext) {
        var _a, _b;
        var _c;
        this._preProcessors = preProcessors;
        var webgpuProcessingContext = processingContext;
        var uniformRegex = new RegExp(/\s*uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm);
        var match = uniformRegex.exec(uniform);
        if (match != null) {
            var uniformType = match[1];
            var name_3 = match[2];
            if (uniformType.indexOf("sampler") === 0 || uniformType.indexOf("sampler") === 1) {
                var samplerInfo = _knownSamplers[name_3];
                var arraySize = 0; // 0 means the sampler/texture is not declared as an array
                if (!samplerInfo) {
                    _a = this._getArraySize(name_3, preProcessors), name_3 = _a[0], arraySize = _a[1];
                    samplerInfo = webgpuProcessingContext.availableSamplers[name_3];
                    if (!samplerInfo) {
                        samplerInfo = {
                            sampler: webgpuProcessingContext.getNextFreeUBOBinding(),
                            isTextureArray: arraySize > 0,
                            textures: [],
                        };
                        for (var i = 0; i < (arraySize || 1); ++i) {
                            samplerInfo.textures.push(webgpuProcessingContext.getNextFreeUBOBinding());
                        }
                    }
                    else {
                        arraySize = samplerInfo.isTextureArray ? samplerInfo.textures.length : 0;
                    }
                }
                var componentType = uniformType.charAt(0) === 'u' ? 'u' : uniformType.charAt(0) === 'i' ? 'i' : '';
                if (componentType) {
                    uniformType = uniformType.substr(1);
                }
                var isTextureArray = arraySize > 0;
                var samplerSetIndex = samplerInfo.sampler.setIndex;
                var samplerBindingIndex = samplerInfo.sampler.bindingIndex;
                var samplerFunction = _samplerFunctionByWebGLSamplerType[uniformType];
                var samplerType = (_c = _samplerTypeByWebGLSamplerType[uniformType]) !== null && _c !== void 0 ? _c : "sampler";
                var textureType = _textureTypeByWebGLSamplerType[uniformType];
                var textureDimension = _gpuTextureViewDimensionByWebGPUTextureType[textureType];
                var isComparisonSampler = !!_isComparisonSamplerByWebGPUSamplerType[samplerType];
                // Manage textures and samplers.
                if (!isTextureArray) {
                    arraySize = 1;
                    uniform = "layout(set = " + samplerSetIndex + ", binding = " + samplerBindingIndex + ") uniform " + componentType + samplerType + " " + name_3 + "Sampler;\n                        layout(set = " + samplerInfo.textures[0].setIndex + ", binding = " + samplerInfo.textures[0].bindingIndex + ") uniform " + textureType + " " + name_3 + "Texture;\n                        #define " + name_3 + " " + componentType + samplerFunction + "(" + name_3 + "Texture, " + name_3 + "Sampler)";
                }
                else {
                    var layouts = [];
                    layouts.push("layout(set = " + samplerSetIndex + ", binding = " + samplerBindingIndex + ") uniform " + componentType + samplerType + " " + name_3 + "Sampler;");
                    uniform = "\r\n";
                    for (var i = 0; i < arraySize; ++i) {
                        var textureSetIndex = samplerInfo.textures[i].setIndex;
                        var textureBindingIndex = samplerInfo.textures[i].bindingIndex;
                        layouts.push("layout(set = " + textureSetIndex + ", binding = " + textureBindingIndex + ") uniform " + textureType + " " + name_3 + "Texture" + i + ";");
                        uniform += (i > 0 ? '\r\n' : '') + "#define " + name_3 + i + " " + componentType + samplerFunction + "(" + name_3 + "Texture" + i + ", " + name_3 + "Sampler)";
                    }
                    uniform = layouts.join('\r\n') + uniform;
                    this._textureArrayProcessing.push(name_3);
                }
                webgpuProcessingContext.availableSamplers[name_3] = samplerInfo;
                if (!webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex]) {
                    webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex] = [];
                }
                if (!webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex][samplerBindingIndex]) {
                    webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex][samplerBindingIndex] = {
                        isSampler: true,
                        isTexture: false,
                        isComparisonSampler: isComparisonSampler,
                        usedInVertex: false,
                        usedInFragment: false,
                        name: name_3,
                    };
                }
                if (isFragment) {
                    webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex][samplerBindingIndex].usedInFragment = true;
                }
                else {
                    webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex][samplerBindingIndex].usedInVertex = true;
                }
                for (var i = 0; i < arraySize; ++i) {
                    var textureSetIndex = samplerInfo.textures[i].setIndex;
                    var textureBindingIndex = samplerInfo.textures[i].bindingIndex;
                    if (!webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex]) {
                        webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex] = [];
                    }
                    if (!webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex][textureBindingIndex]) {
                        webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex][textureBindingIndex] = {
                            isSampler: false,
                            isTexture: true,
                            sampleType: isComparisonSampler ? WebGPUConstants.TextureSampleType.Depth :
                                componentType === 'u' ? WebGPUConstants.TextureSampleType.Uint :
                                    componentType === 'i' ? WebGPUConstants.TextureSampleType.Sint : WebGPUConstants.TextureSampleType.Float,
                            textureDimension: textureDimension,
                            usedInVertex: false,
                            usedInFragment: false,
                            name: isTextureArray ? name_3 + i.toString() : name_3,
                        };
                    }
                    if (isFragment) {
                        webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex][textureBindingIndex].usedInFragment = true;
                    }
                    else {
                        webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex][textureBindingIndex].usedInVertex = true;
                    }
                }
            }
            else {
                // Check the size of the uniform array in case of array.
                var length_1 = 0;
                _b = this._getArraySize(name_3, preProcessors), name_3 = _b[0], length_1 = _b[1];
                for (var i = 0; i < webgpuProcessingContext.leftOverUniforms.length; i++) {
                    if (webgpuProcessingContext.leftOverUniforms[i].name === name_3) {
                        return "";
                    }
                }
                webgpuProcessingContext.leftOverUniforms.push({
                    name: name_3,
                    type: uniformType,
                    length: length_1
                });
                uniform = "";
            }
        }
        return uniform;
    };
    WebGPUShaderProcessor.prototype.uniformBufferProcessor = function (uniformBuffer, isFragment, processingContext) {
        var webgpuProcessingContext = processingContext;
        var uboRegex = new RegExp(/uniform\s+(\w+)/gm);
        var match = uboRegex.exec(uniformBuffer);
        if (match != null) {
            var name_4 = match[1];
            var setIndex = void 0;
            var bindingIndex = void 0;
            var knownUBO = _knownUBOs[name_4];
            if (knownUBO) {
                setIndex = knownUBO.setIndex;
                bindingIndex = knownUBO.bindingIndex;
            }
            else {
                if (isFragment) {
                    var availableUBO = webgpuProcessingContext.availableUBOs[name_4];
                    if (availableUBO) {
                        setIndex = availableUBO.setIndex;
                        bindingIndex = availableUBO.bindingIndex;
                    }
                    else {
                        var nextBinding = webgpuProcessingContext.getNextFreeUBOBinding();
                        setIndex = nextBinding.setIndex;
                        bindingIndex = nextBinding.bindingIndex;
                    }
                }
                else {
                    var nextBinding = webgpuProcessingContext.getNextFreeUBOBinding();
                    setIndex = nextBinding.setIndex;
                    bindingIndex = nextBinding.bindingIndex;
                }
            }
            webgpuProcessingContext.availableUBOs[name_4] = { setIndex: setIndex, bindingIndex: bindingIndex };
            if (!webgpuProcessingContext.orderedUBOsAndSamplers[setIndex]) {
                webgpuProcessingContext.orderedUBOsAndSamplers[setIndex] = [];
            }
            if (!webgpuProcessingContext.orderedUBOsAndSamplers[setIndex][bindingIndex]) {
                webgpuProcessingContext.orderedUBOsAndSamplers[setIndex][bindingIndex] = { isSampler: false, isTexture: false, name: name_4, usedInVertex: false, usedInFragment: false };
            }
            if (isFragment) {
                webgpuProcessingContext.orderedUBOsAndSamplers[setIndex][bindingIndex].usedInFragment = true;
            }
            else {
                webgpuProcessingContext.orderedUBOsAndSamplers[setIndex][bindingIndex].usedInVertex = true;
            }
            uniformBuffer = uniformBuffer.replace("uniform", "layout(set = " + setIndex + ", binding = " + bindingIndex + ") uniform");
        }
        return uniformBuffer;
    };
    // public endOfUniformBufferProcessor(closingBracketLine: string, isFragment: boolean): string {
    //     console.log("uniformBuffer closingBracketLine ", closingBracketLine);
    //     return closingBracketLine;
    // }
    WebGPUShaderProcessor.prototype.postProcessor = function (code, defines, isFragment, processingContext, engine) {
        var hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
        // Remove extensions
        var regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
        code = code.replace(regex, "");
        // Replace instructions
        code = code.replace(/texture2D\s*\(/g, "texture(");
        if (isFragment) {
            code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
            code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
            code = code.replace(/textureCube\s*\(/g, "texture(");
            code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
            code = code.replace(/gl_FragColor/g, "glFragColor");
            code = code.replace(/gl_FragData/g, "glFragData");
            code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension ? "" : "layout(location = 0) out vec4 glFragColor;\n") + "void main(");
        }
        else {
            code = code.replace(/gl_InstanceID/g, "gl_InstanceIndex");
            code = code.replace(/gl_VertexID/g, "gl_VertexIndex");
            var hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
            if (hasMultiviewExtension) {
                return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
            }
        }
        // Flip Y + convert z range from [-1,1] to [0,1]
        if (!isFragment) {
            var lastClosingCurly = code.lastIndexOf("}");
            code = code.substring(0, lastClosingCurly);
            code += "gl_Position.y *= -1.;\n";
            if (!engine.isNDCHalfZRange) {
                code += "gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\n";
            }
            code += "}";
        }
        return code;
    };
    WebGPUShaderProcessor.prototype._applyTextureArrayProcessing = function (code, name) {
        // Replaces the occurrences of name[XX] by nameXX
        var regex = new RegExp(name + "\\s*\\[(.+)?\\]", "gm");
        var match = regex.exec(code);
        while (match != null) {
            var index = match[1];
            var iindex = +(index);
            if (this._preProcessors && isNaN(iindex)) {
                iindex = +(this._preProcessors[index.trim()]);
            }
            code = code.replace(match[0], name + iindex);
            match = regex.exec(code);
        }
        return code;
    };
    WebGPUShaderProcessor.prototype.finalizeShaders = function (vertexCode, fragmentCode, processingContext) {
        var webgpuProcessingContext = processingContext;
        // make replacements for texture names in the texture array case
        for (var i = 0; i < this._textureArrayProcessing.length; ++i) {
            var name_5 = this._textureArrayProcessing[i];
            vertexCode = this._applyTextureArrayProcessing(vertexCode, name_5);
            fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name_5);
        }
        // inject the missing varying in the fragment shader
        for (var i = 0; i < this._missingVaryings.length; ++i) {
            var decl = this._missingVaryings[i];
            if (decl && decl.length > 0) {
                fragmentCode = decl + "\n" + fragmentCode;
            }
        }
        // Builds the leftover UBOs.
        if (webgpuProcessingContext.leftOverUniforms.length) {
            var name_6 = "LeftOver";
            var availableUBO = webgpuProcessingContext.availableUBOs[name_6];
            if (!availableUBO) {
                availableUBO = webgpuProcessingContext.getNextFreeUBOBinding();
                webgpuProcessingContext.availableUBOs[name_6] = availableUBO;
                if (!webgpuProcessingContext.orderedUBOsAndSamplers[availableUBO.setIndex]) {
                    webgpuProcessingContext.orderedUBOsAndSamplers[availableUBO.setIndex] = [];
                }
                webgpuProcessingContext.orderedUBOsAndSamplers[availableUBO.setIndex][availableUBO.bindingIndex] = { isSampler: false, isTexture: false, usedInVertex: true, usedInFragment: true, name: name_6 };
            }
            var ubo = "layout(set = " + availableUBO.setIndex + ", binding = " + availableUBO.bindingIndex + ") uniform " + name_6 + " {\n    ";
            for (var _i = 0, _a = webgpuProcessingContext.leftOverUniforms; _i < _a.length; _i++) {
                var leftOverUniform = _a[_i];
                if (leftOverUniform.length > 0) {
                    ubo += "    " + leftOverUniform.type + " " + leftOverUniform.name + "[" + leftOverUniform.length + "];\n";
                }
                else {
                    ubo += "    " + leftOverUniform.type + " " + leftOverUniform.name + ";\n";
                }
            }
            ubo += "};\n\n";
            // Currently set in both vert and frag but could be optim away if necessary.
            vertexCode = ubo + vertexCode;
            fragmentCode = ubo + fragmentCode;
        }
        // collect all the buffer names for faster processing later in _getBindGroupsToRender
        for (var i = 0; i < webgpuProcessingContext.orderedUBOsAndSamplers.length; i++) {
            var setDefinition = webgpuProcessingContext.orderedUBOsAndSamplers[i];
            if (setDefinition === undefined) {
                continue;
            }
            for (var j = 0; j < setDefinition.length; j++) {
                var bindingDefinition = webgpuProcessingContext.orderedUBOsAndSamplers[i][j];
                if (bindingDefinition && !bindingDefinition.isSampler && !bindingDefinition.isTexture) {
                    webgpuProcessingContext.uniformBufferNames.push(bindingDefinition.name);
                }
            }
        }
        this._preProcessors = null;
        return { vertexCode: vertexCode, fragmentCode: fragmentCode };
    };
    return WebGPUShaderProcessor;
}());
export { WebGPUShaderProcessor };
//# sourceMappingURL=webgpuShaderProcessors.js.map