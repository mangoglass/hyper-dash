{"version":3,"file":"webgpuShaderProcessors.js","sourceRoot":"","sources":["../../../../sourceES6/core/Engines/WebGPU/webgpuShaderProcessors.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from '../../types';\r\nimport { IShaderProcessor } from '../Processors/iShaderProcessor';\r\nimport { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport { WebGPUTextureSamplerBindingDescription, WebGPUShaderProcessingContext } from './webgpuShaderProcessingContext';\r\nimport * as WebGPUConstants from './webgpuConstants';\r\nimport { Logger } from '../../Misc/logger';\r\nimport { ThinEngine } from \"../thinEngine\";\r\n\r\nconst _knownUBOs: { [key: string]: { setIndex: number, bindingIndex: number} } = {\r\n    \"Scene\": { setIndex: 0, bindingIndex: 0 },\r\n    \"Light0\": { setIndex: 0, bindingIndex: 5 },\r\n    \"Light1\": { setIndex: 0, bindingIndex: 6 },\r\n    \"Light2\": { setIndex: 0, bindingIndex: 7 },\r\n    \"Light3\": { setIndex: 0, bindingIndex: 8 },\r\n    \"Light4\": { setIndex: 0, bindingIndex: 9 },\r\n    \"Light5\": { setIndex: 0, bindingIndex: 10 },\r\n    \"Light6\": { setIndex: 0, bindingIndex: 11 },\r\n    \"Light7\": { setIndex: 0, bindingIndex: 12 },\r\n    \"Light8\": { setIndex: 0, bindingIndex: 13 },\r\n    \"Material\": { setIndex: 1, bindingIndex: 0 },\r\n    \"Mesh\": { setIndex: 1, bindingIndex: 1 },\r\n};\r\n\r\nconst _knownSamplers: { [key: string]: WebGPUTextureSamplerBindingDescription } = {\r\n    \"environmentBrdfSampler\": { sampler: { setIndex: 0, bindingIndex: 1 }, isTextureArray: false, textures: [{ setIndex: 0, bindingIndex: 2 }] },\r\n    // \"reflectionSampler\": { setIndex: 0, bindingIndex: 3 },\r\n};\r\n\r\n// TODO WEBGPU. sampler3D\r\nconst _samplerFunctionByWebGLSamplerType: { [key: string]: string } = {\r\n    \"sampler2D\": \"sampler2D\",\r\n    \"sampler2DArray\": \"sampler2DArray\",\r\n    \"sampler2DShadow\": \"sampler2DShadow\",\r\n    \"sampler2DArrayShadow\": \"sampler2DArrayShadow\",\r\n    \"samplerCube\": \"samplerCube\"\r\n};\r\n\r\nconst _textureTypeByWebGLSamplerType: { [key: string]: string } = {\r\n    \"sampler2D\": \"texture2D\",\r\n    \"sampler2DArray\": \"texture2DArray\",\r\n    \"sampler2DShadow\": \"texture2D\",\r\n    \"sampler2DArrayShadow\": \"texture2DArray\",\r\n    \"samplerCube\": \"textureCube\",\r\n    \"samplerCubeArray\": \"textureCubeArray\"\r\n};\r\n\r\nconst _gpuTextureViewDimensionByWebGPUTextureType: { [key: string]: GPUTextureViewDimension } = {\r\n    \"textureCube\": WebGPUConstants.TextureViewDimension.Cube,\r\n    \"textureCubeArray\": WebGPUConstants.TextureViewDimension.CubeArray,\r\n    \"texture2D\": WebGPUConstants.TextureViewDimension.E2d,\r\n    \"texture2DArray\": WebGPUConstants.TextureViewDimension.E2dArray,\r\n};\r\n\r\n// if the webgl sampler type is not listed in this array, \"sampler\" is taken by default\r\nconst _samplerTypeByWebGLSamplerType: { [key: string]: string } = {\r\n    \"sampler2DShadow\": \"samplerShadow\",\r\n    \"sampler2DArrayShadow\": \"samplerShadow\",\r\n};\r\n\r\nconst _isComparisonSamplerByWebGPUSamplerType: { [key: string]: boolean } = {\r\n    \"samplerShadow\": true,\r\n    \"samplerArrayShadow\": true,\r\n    \"sampler\": false,\r\n};\r\n\r\n/** @hidden */\r\nexport class WebGPUShaderProcessor implements IShaderProcessor {\r\n\r\n    protected _missingVaryings: Array<string> = [];\r\n    protected _textureArrayProcessing: Array<string> = [];\r\n    protected _preProcessors: { [key: string]: string };\r\n\r\n    private _getArraySize(name: string, preProcessors: { [key: string]: string }): [string, number] {\r\n        let length = 0;\r\n        const startArray = name.indexOf(\"[\");\r\n        const endArray = name.indexOf(\"]\");\r\n        if (startArray > 0 && endArray > 0) {\r\n            const lengthInString = name.substring(startArray + 1, endArray);\r\n            length = +(lengthInString);\r\n            if (isNaN(length)) {\r\n                length = +(preProcessors[lengthInString.trim()]);\r\n            }\r\n            name = name.substr(0, startArray);\r\n        }\r\n        return [name, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<ShaderProcessingContext>): void {\r\n        this._missingVaryings.length = 0;\r\n        this._textureArrayProcessing.length = 0;\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }, processingContext: Nullable<ShaderProcessingContext>) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const webgpuProcessingContext = processingContext! as WebGPUShaderProcessingContext;\r\n\r\n        const varyingRegex = new RegExp(/\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm);\r\n        const match = varyingRegex.exec(varying);\r\n        if (match != null) {\r\n            const varyingType = match[1];\r\n            const name = match[2];\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = webgpuProcessingContext.availableVaryings[name];\r\n                this._missingVaryings[location] = \"\";\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            }\r\n            else {\r\n                location = webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, preProcessors)[1]);\r\n                webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._missingVaryings[location] = `layout(location = ${location}) in ${varyingType} ${name};`;\r\n            }\r\n\r\n            varying = varying.replace(match[0], location === undefined ? \"\" : `layout(location = ${location}) ${isFragment ? \"in\" : \"out\"} ${varyingType} ${name};`);\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }, processingContext: Nullable<ShaderProcessingContext>) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const webgpuProcessingContext = processingContext! as WebGPUShaderProcessingContext;\r\n\r\n        const attribRegex = new RegExp(/\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm);\r\n        const match = attribRegex.exec(attribute);\r\n        if (match != null) {\r\n            const varyingType = match[1];\r\n            const name = match[2];\r\n            const location = webgpuProcessingContext.getAttributeNextLocation(varyingType, this._getArraySize(name, preProcessors)[1]);\r\n\r\n            webgpuProcessingContext.availableAttributes[name] = location;\r\n            webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            attribute = attribute.replace(match[0], `layout(location = ${location}) in ${varyingType} ${name};`);\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }, processingContext: Nullable<ShaderProcessingContext>): string {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const webgpuProcessingContext = processingContext! as WebGPUShaderProcessingContext;\r\n\r\n        const uniformRegex = new RegExp(/\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm);\r\n\r\n        const match = uniformRegex.exec(uniform);\r\n        if (match != null) {\r\n            let uniformType = match[1];\r\n            let name = match[2];\r\n\r\n            if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\r\n                let samplerInfo = _knownSamplers[name];\r\n                let arraySize = 0; // 0 means the sampler/texture is not declared as an array\r\n                if (!samplerInfo) {\r\n                    [name, arraySize] = this._getArraySize(name, preProcessors);\r\n                    samplerInfo = webgpuProcessingContext.availableSamplers[name];\r\n                    if (!samplerInfo) {\r\n                        samplerInfo = {\r\n                            sampler: webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                            isTextureArray: arraySize > 0,\r\n                            textures: [],\r\n                        };\r\n                        for (let i = 0; i < (arraySize || 1); ++i) {\r\n                            samplerInfo.textures.push(webgpuProcessingContext.getNextFreeUBOBinding());\r\n                        }\r\n                    } else {\r\n                        arraySize = samplerInfo.isTextureArray ? samplerInfo.textures.length : 0;\r\n                    }\r\n                }\r\n\r\n                const componentType = uniformType.charAt(0) === 'u' ? 'u' : uniformType.charAt(0) === 'i' ? 'i' : '';\r\n\r\n                if (componentType) {\r\n                    uniformType = uniformType.substr(1);\r\n                }\r\n\r\n                const isTextureArray = arraySize > 0;\r\n                const samplerSetIndex = samplerInfo.sampler.setIndex;\r\n                const samplerBindingIndex = samplerInfo.sampler.bindingIndex;\r\n                const samplerFunction = _samplerFunctionByWebGLSamplerType[uniformType];\r\n                const samplerType = _samplerTypeByWebGLSamplerType[uniformType] ?? \"sampler\";\r\n                const textureType = _textureTypeByWebGLSamplerType[uniformType];\r\n                const textureDimension = _gpuTextureViewDimensionByWebGPUTextureType[textureType];\r\n                const isComparisonSampler = !!_isComparisonSamplerByWebGPUSamplerType[samplerType];\r\n\r\n                // Manage textures and samplers.\r\n                if (!isTextureArray) {\r\n                    arraySize = 1;\r\n                    uniform = `layout(set = ${samplerSetIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${name}Sampler;\r\n                        layout(set = ${samplerInfo.textures[0].setIndex}, binding = ${samplerInfo.textures[0].bindingIndex}) uniform ${textureType} ${name}Texture;\r\n                        #define ${name} ${componentType}${samplerFunction}(${name}Texture, ${name}Sampler)`;\r\n                } else {\r\n                    let layouts = [];\r\n                    layouts.push(`layout(set = ${samplerSetIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${name}Sampler;`);\r\n                    uniform = `\\r\\n`;\r\n                    for (let i = 0; i < arraySize; ++i) {\r\n                        const textureSetIndex = samplerInfo.textures[i].setIndex;\r\n                        const textureBindingIndex = samplerInfo.textures[i].bindingIndex;\r\n\r\n                        layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name}Texture${i};`);\r\n\r\n                        uniform += `${i > 0 ? '\\r\\n' : ''}#define ${name}${i} ${componentType}${samplerFunction}(${name}Texture${i}, ${name}Sampler)`;\r\n                    }\r\n                    uniform = layouts.join('\\r\\n') + uniform;\r\n                    this._textureArrayProcessing.push(name);\r\n                }\r\n\r\n                webgpuProcessingContext.availableSamplers[name] = samplerInfo;\r\n\r\n                if (!webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex]) {\r\n                    webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex] = [];\r\n                }\r\n                if (!webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex][samplerBindingIndex]) {\r\n                    webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex][samplerBindingIndex] = {\r\n                        isSampler: true,\r\n                        isTexture: false,\r\n                        isComparisonSampler,\r\n                        usedInVertex: false,\r\n                        usedInFragment: false,\r\n                        name,\r\n                    };\r\n                }\r\n\r\n                if (isFragment) {\r\n                    webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex][samplerBindingIndex].usedInFragment = true;\r\n                } else {\r\n                    webgpuProcessingContext.orderedUBOsAndSamplers[samplerSetIndex][samplerBindingIndex].usedInVertex = true;\r\n                }\r\n\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    const textureSetIndex = samplerInfo.textures[i].setIndex;\r\n                    const textureBindingIndex = samplerInfo.textures[i].bindingIndex;\r\n\r\n                    if (!webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex]) {\r\n                        webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex] = [];\r\n                    }\r\n                    if (!webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex][textureBindingIndex]) {\r\n                        webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex][textureBindingIndex] = {\r\n                            isSampler: false,\r\n                            isTexture: true,\r\n                            sampleType: isComparisonSampler ? WebGPUConstants.TextureSampleType.Depth :\r\n                                        componentType === 'u' ? WebGPUConstants.TextureSampleType.Uint :\r\n                                        componentType === 'i' ? WebGPUConstants.TextureSampleType.Sint : WebGPUConstants.TextureSampleType.Float,\r\n                            textureDimension,\r\n                            usedInVertex: false,\r\n                            usedInFragment: false,\r\n                            name: isTextureArray ? name + i.toString() : name,\r\n                        };\r\n                    }\r\n                    if (isFragment) {\r\n                        webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex][textureBindingIndex].usedInFragment = true;\r\n                    } else {\r\n                        webgpuProcessingContext.orderedUBOsAndSamplers[textureSetIndex][textureBindingIndex].usedInVertex = true;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Check the size of the uniform array in case of array.\r\n                let length = 0;\r\n\r\n                [name, length] = this._getArraySize(name, preProcessors);\r\n\r\n                for (let i = 0; i < webgpuProcessingContext.leftOverUniforms.length; i++) {\r\n                    if (webgpuProcessingContext.leftOverUniforms[i].name === name) {\r\n                        return \"\";\r\n                    }\r\n                }\r\n\r\n                webgpuProcessingContext.leftOverUniforms.push({\r\n                    name,\r\n                    type: uniformType,\r\n                    length\r\n                });\r\n                uniform = \"\";\r\n            }\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public uniformBufferProcessor(uniformBuffer: string, isFragment: boolean, processingContext: Nullable<ShaderProcessingContext>): string {\r\n        const webgpuProcessingContext = processingContext! as WebGPUShaderProcessingContext;\r\n        const uboRegex = new RegExp(/uniform\\s+(\\w+)/gm);\r\n\r\n        const match = uboRegex.exec(uniformBuffer);\r\n        if (match != null) {\r\n            const name = match[1];\r\n            let setIndex: number;\r\n            let bindingIndex: number;\r\n            const knownUBO = _knownUBOs[name];\r\n            if (knownUBO) {\r\n                setIndex = knownUBO.setIndex;\r\n                bindingIndex = knownUBO.bindingIndex;\r\n            }\r\n            else {\r\n                if (isFragment) {\r\n                    const availableUBO = webgpuProcessingContext.availableUBOs[name];\r\n                    if (availableUBO) {\r\n                        setIndex = availableUBO.setIndex;\r\n                        bindingIndex = availableUBO.bindingIndex;\r\n                    }\r\n                    else {\r\n                        const nextBinding = webgpuProcessingContext.getNextFreeUBOBinding();\r\n                        setIndex = nextBinding.setIndex;\r\n                        bindingIndex = nextBinding.bindingIndex;\r\n                    }\r\n                }\r\n                else {\r\n                    const nextBinding = webgpuProcessingContext.getNextFreeUBOBinding();\r\n                    setIndex = nextBinding.setIndex;\r\n                    bindingIndex = nextBinding.bindingIndex;\r\n                }\r\n            }\r\n\r\n            webgpuProcessingContext.availableUBOs[name] = { setIndex, bindingIndex };\r\n            if (!webgpuProcessingContext.orderedUBOsAndSamplers[setIndex]) {\r\n                webgpuProcessingContext.orderedUBOsAndSamplers[setIndex] = [];\r\n            }\r\n            if (!webgpuProcessingContext.orderedUBOsAndSamplers[setIndex][bindingIndex]) {\r\n                webgpuProcessingContext.orderedUBOsAndSamplers[setIndex][bindingIndex] = { isSampler: false, isTexture: false, name, usedInVertex: false, usedInFragment: false };\r\n            }\r\n            if (isFragment) {\r\n                webgpuProcessingContext.orderedUBOsAndSamplers[setIndex][bindingIndex].usedInFragment = true;\r\n            } else {\r\n                webgpuProcessingContext.orderedUBOsAndSamplers[setIndex][bindingIndex].usedInVertex = true;\r\n            }\r\n\r\n            uniformBuffer = uniformBuffer.replace(\"uniform\", `layout(set = ${setIndex}, binding = ${bindingIndex}) uniform`);\r\n        }\r\n        return uniformBuffer;\r\n    }\r\n\r\n    // public endOfUniformBufferProcessor(closingBracketLine: string, isFragment: boolean): string {\r\n    //     console.log(\"uniformBuffer closingBracketLine \", closingBracketLine);\r\n    //     return closingBracketLine;\r\n    // }\r\n\r\n    public postProcessor(code: string, defines: string[], isFragment: boolean, processingContext: Nullable<ShaderProcessingContext>, engine: ThinEngine) {\r\n        const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\r\n\r\n        // Remove extensions\r\n        var regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\r\n        code = code.replace(regex, \"\");\r\n\r\n        // Replace instructions\r\n        code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\r\n        if (isFragment) {\r\n            code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\r\n            code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\r\n            code = code.replace(/gl_FragColor/g, \"glFragColor\");\r\n            code = code.replace(/gl_FragData/g, \"glFragData\");\r\n            code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\r\n        } else {\r\n            code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\r\n            code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\r\n            var hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\r\n            if (hasMultiviewExtension) {\r\n                return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\r\n            }\r\n        }\r\n\r\n        // Flip Y + convert z range from [-1,1] to [0,1]\r\n        if (!isFragment) {\r\n            const lastClosingCurly = code.lastIndexOf(\"}\");\r\n            code = code.substring(0, lastClosingCurly);\r\n            code += \"gl_Position.y *= -1.;\\n\";\r\n            if (!engine.isNDCHalfZRange) {\r\n                code += \"gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\\n\";\r\n            }\r\n            code += \"}\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _applyTextureArrayProcessing(code: string, name: string): string {\r\n        // Replaces the occurrences of name[XX] by nameXX\r\n        const regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\r\n        let match = regex.exec(code);\r\n\r\n        while (match != null) {\r\n            let index = match[1];\r\n            let iindex = +(index);\r\n            if (this._preProcessors && isNaN(iindex)) {\r\n                iindex = +(this._preProcessors[index.trim()]);\r\n            }\r\n            code = code.replace(match[0], name + iindex);\r\n            match = regex.exec(code);\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string, processingContext: Nullable<ShaderProcessingContext>): { vertexCode: string, fragmentCode: string } {\r\n        const webgpuProcessingContext = processingContext! as WebGPUShaderProcessingContext;\r\n\r\n        // make replacements for texture names in the texture array case\r\n        for (let i = 0; i < this._textureArrayProcessing.length; ++i) {\r\n            const name = this._textureArrayProcessing[i];\r\n            vertexCode = this._applyTextureArrayProcessing(vertexCode, name);\r\n            fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name);\r\n        }\r\n\r\n        // inject the missing varying in the fragment shader\r\n        for (let i = 0; i < this._missingVaryings.length; ++i) {\r\n            const decl = this._missingVaryings[i];\r\n            if (decl && decl.length > 0) {\r\n                fragmentCode = decl + \"\\n\" + fragmentCode;\r\n            }\r\n        }\r\n\r\n        // Builds the leftover UBOs.\r\n        if (webgpuProcessingContext.leftOverUniforms.length) {\r\n            const name = \"LeftOver\";\r\n            let availableUBO = webgpuProcessingContext.availableUBOs[name];\r\n            if (!availableUBO) {\r\n                availableUBO = webgpuProcessingContext.getNextFreeUBOBinding();\r\n                webgpuProcessingContext.availableUBOs[name] = availableUBO;\r\n                if (!webgpuProcessingContext.orderedUBOsAndSamplers[availableUBO.setIndex]) {\r\n                    webgpuProcessingContext.orderedUBOsAndSamplers[availableUBO.setIndex] = [];\r\n                }\r\n                webgpuProcessingContext.orderedUBOsAndSamplers[availableUBO.setIndex][availableUBO.bindingIndex] = { isSampler: false, isTexture: false, usedInVertex: true, usedInFragment: true, name };\r\n            }\r\n\r\n            let ubo = `layout(set = ${availableUBO.setIndex}, binding = ${availableUBO.bindingIndex}) uniform ${name} {\\n    `;\r\n            for (let leftOverUniform of webgpuProcessingContext.leftOverUniforms) {\r\n                if (leftOverUniform.length > 0) {\r\n                    ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];\\n`;\r\n                }\r\n                else {\r\n                    ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};\\n`;\r\n                }\r\n            }\r\n            ubo += \"};\\n\\n\";\r\n\r\n            // Currently set in both vert and frag but could be optim away if necessary.\r\n            vertexCode = ubo + vertexCode;\r\n            fragmentCode = ubo + fragmentCode;\r\n        }\r\n\r\n        // collect all the buffer names for faster processing later in _getBindGroupsToRender\r\n        for (let i = 0; i < webgpuProcessingContext.orderedUBOsAndSamplers.length; i++) {\r\n            const setDefinition = webgpuProcessingContext.orderedUBOsAndSamplers[i];\r\n            if (setDefinition === undefined) {\r\n                continue;\r\n            }\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const bindingDefinition = webgpuProcessingContext.orderedUBOsAndSamplers[i][j];\r\n                if (bindingDefinition && !bindingDefinition.isSampler && !bindingDefinition.isTexture) {\r\n                    webgpuProcessingContext.uniformBufferNames.push(bindingDefinition.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._preProcessors = null as any;\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n}"]}