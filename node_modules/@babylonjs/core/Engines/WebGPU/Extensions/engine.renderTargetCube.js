import { __assign } from "tslib";
import { InternalTexture, InternalTextureSource } from "../../../Materials/Textures/internalTexture";
import { WebGPUEngine } from "../../webgpuEngine";
WebGPUEngine.prototype.createRenderTargetCubeTexture = function (size, options) {
    var fullOptions = __assign({ generateMipMaps: true, generateDepthBuffer: true, generateStencilBuffer: false, type: 0, samplingMode: 3, format: 5, samples: 1 }, options);
    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
    var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
    texture.width = size;
    texture.height = size;
    texture.depth = 0;
    texture.isReady = true;
    texture.isCube = true;
    texture.samples = fullOptions.samples;
    texture.generateMipMaps = fullOptions.generateMipMaps;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    texture.format = fullOptions.format;
    texture._generateDepthBuffer = fullOptions.generateDepthBuffer;
    texture._generateStencilBuffer = fullOptions.generateStencilBuffer;
    this._internalTexturesCache.push(texture);
    if (texture._generateDepthBuffer || texture._generateStencilBuffer) {
        texture._depthStencilTexture = this.createDepthStencilTexture({ width: texture.width, height: texture.height, layers: texture.depth }, {
            bilinearFiltering: fullOptions.samplingMode === undefined ||
                fullOptions.samplingMode === 2 || fullOptions.samplingMode === 2 ||
                fullOptions.samplingMode === 3 || fullOptions.samplingMode === 3 ||
                fullOptions.samplingMode === 5 || fullOptions.samplingMode === 6 ||
                fullOptions.samplingMode === 7 || fullOptions.samplingMode === 11,
            comparisonFunction: 0,
            generateStencil: texture._generateStencilBuffer,
            isCube: texture.isCube,
            samples: texture.samples,
        });
    }
    if (options && options.createMipMaps && !fullOptions.generateMipMaps) {
        texture.generateMipMaps = true;
    }
    this._textureHelper.createGPUTextureForInternalTexture(texture);
    if (options && options.createMipMaps && !fullOptions.generateMipMaps) {
        texture.generateMipMaps = false;
    }
    return texture;
};
//# sourceMappingURL=engine.renderTargetCube.js.map