import { Logger } from "../../Misc/logger";
var WebGPUBindGroupCacheNode = /** @class */ (function () {
    function WebGPUBindGroupCacheNode() {
        this.values = {};
    }
    return WebGPUBindGroupCacheNode;
}());
/** @hidden */
var WebGPUCacheBindGroups = /** @class */ (function () {
    function WebGPUCacheBindGroups(device, cacheSampler, engine) {
        this.disabled = false;
        this._device = device;
        this._cacheSampler = cacheSampler;
        this._engine = engine;
    }
    WebGPUCacheBindGroups.prototype.endFrame = function () {
        WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;
        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;
    };
    /**
     * Cache is currently based on the uniform buffers and textures used by the binding groups.
     * In Babylon we don't have a separate standalone sampler object, the sampler properties (wrapU, wrapV, samplingMode, ...) are held by the (internal) texture itself.
     * When one of these properties change for a texture (which normally does not happen often), we remove the corresponding entries from the cache (that is, all the entries
     * that reference this texture, hence the need for _CacheTextures - see WebGPUCacheBindGroups.clearTextureEntries and WebGPUMaterialContext.setTexture)
     * Note also that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:
     * that means we don't need to factor in the offset/size of the buffer in the cache, only the id
     */
    WebGPUCacheBindGroups.prototype.getBindGroups = function (webgpuPipelineContext, materialContext, uniformsBuffers) {
        var _a, _b, _c, _d;
        var bindGroups = undefined;
        var node = WebGPUCacheBindGroups._Cache;
        if (!this.disabled) {
            for (var _i = 0, _e = webgpuPipelineContext.shaderProcessingContext.uniformBufferNames; _i < _e.length; _i++) {
                var bufferName = _e[_i];
                var uboId = uniformsBuffers[bufferName].uniqueId;
                var nextNode = node.values[uboId];
                if (!nextNode) {
                    nextNode = new WebGPUBindGroupCacheNode();
                    node.values[uboId] = nextNode;
                }
                node = nextNode;
            }
            for (var _f = 0, _g = webgpuPipelineContext.shaderProcessingContext.samplerNames; _f < _g.length; _f++) {
                var samplerName = _g[_f];
                var textureId = (_c = (_b = (_a = materialContext.textures[samplerName]) === null || _a === void 0 ? void 0 : _a.texture) === null || _b === void 0 ? void 0 : _b.uniqueId) !== null && _c !== void 0 ? _c : 0;
                var nextNode = node.values[textureId];
                if (!nextNode) {
                    nextNode = new WebGPUBindGroupCacheNode();
                    node.values[textureId] = nextNode;
                    var textureEntries = WebGPUCacheBindGroups._CacheTextures[textureId];
                    if (!textureEntries) {
                        textureEntries = WebGPUCacheBindGroups._CacheTextures[textureId] = [];
                    }
                    textureEntries.push(node);
                }
                node = nextNode;
            }
            bindGroups = node.bindGroups;
        }
        if (bindGroups) {
            return bindGroups;
        }
        bindGroups = [];
        if (!this.disabled) {
            node.bindGroups = bindGroups;
        }
        WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;
        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;
        var bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts;
        for (var i = 0; i < webgpuPipelineContext.shaderProcessingContext.orderedUBOsAndSamplers.length; i++) {
            var setDefinition = webgpuPipelineContext.shaderProcessingContext.orderedUBOsAndSamplers[i];
            if (setDefinition === undefined) {
                var groupLayout = bindGroupLayouts[i];
                bindGroups[i] = this._device.createBindGroup({
                    layout: groupLayout,
                    entries: [],
                });
                continue;
            }
            var entries = [];
            for (var j = 0; j < setDefinition.length; j++) {
                var bindingDefinition = webgpuPipelineContext.shaderProcessingContext.orderedUBOsAndSamplers[i][j];
                if (bindingDefinition === undefined) {
                    continue;
                }
                if (bindingDefinition.isSampler) {
                    var bindingInfo = materialContext.samplers[bindingDefinition.name];
                    if (bindingInfo) {
                        var texture = (_d = materialContext.textures[bindingInfo.firstTextureName]) === null || _d === void 0 ? void 0 : _d.texture;
                        if (!texture) {
                            Logger.Error("Could not create the gpu sampler \"" + bindingDefinition.name + "\" because no texture can be looked up for the name \"" + bindingInfo.firstTextureName + "\". bindingInfo=" + JSON.stringify(bindingInfo) + ", materialContext=" + JSON.stringify(materialContext, function (key, value) { return key === 'texture' || key === '_cacheBindGroups' ? '<no dump>' : value; }), 50);
                            continue;
                        }
                        entries.push({
                            binding: j,
                            resource: this._cacheSampler.getSampler(texture),
                        });
                    }
                    else {
                        Logger.Error("Sampler \"" + bindingDefinition.name + "\" could not be bound. bindingDefinition=" + JSON.stringify(bindingDefinition) + ", materialContext=" + JSON.stringify(materialContext, function (key, value) { return key === 'texture' || key === '_cacheBindGroups' ? '<no dump>' : value; }), 50);
                    }
                }
                else if (bindingDefinition.isTexture) {
                    var bindingInfo = materialContext.textures[bindingDefinition.name];
                    if (bindingInfo) {
                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {
                            Logger.Error("Trying to bind a null texture! bindingDefinition=" + JSON.stringify(bindingDefinition) + ", bindingInfo=" + JSON.stringify(bindingInfo, function (key, value) { return key === 'texture' ? '<no dump>' : value; }), 50);
                            continue;
                        }
                        var hardwareTexture = bindingInfo.texture._hardwareTexture;
                        if (this._engine.dbgSanityChecks && !hardwareTexture.view) {
                            Logger.Error("Trying to bind a null gpu texture! bindingDefinition=" + JSON.stringify(bindingDefinition) + ", bindingInfo=" + JSON.stringify(bindingInfo, function (key, value) { return key === 'texture' ? '<no dump>' : value; }) + ", isReady=" + bindingInfo.texture.isReady, 50);
                            continue;
                        }
                        entries.push({
                            binding: j,
                            resource: hardwareTexture.view,
                        });
                    }
                    else {
                        Logger.Error("Texture \"" + bindingDefinition.name + "\" could not be bound. bindingDefinition=" + JSON.stringify(bindingDefinition) + ", materialContext=" + JSON.stringify(materialContext, function (key, value) { return key === 'texture' || key === '_cacheBindGroups' ? '<no dump>' : value; }), 50);
                    }
                }
                else {
                    var dataBuffer = uniformsBuffers[bindingDefinition.name];
                    if (dataBuffer) {
                        var webgpuBuffer = dataBuffer.underlyingResource;
                        entries.push({
                            binding: j,
                            resource: {
                                buffer: webgpuBuffer,
                                offset: 0,
                                size: dataBuffer.capacity,
                            },
                        });
                    }
                    else {
                        Logger.Error("Can't find UBO \"" + bindingDefinition.name + "\". bindingDefinition=" + JSON.stringify(bindingDefinition) + ", _uniformsBuffers=" + JSON.stringify(uniformsBuffers), 50);
                    }
                }
            }
            if (entries.length > 0) {
                var groupLayout = bindGroupLayouts[i];
                bindGroups[i] = this._device.createBindGroup({
                    layout: groupLayout,
                    entries: entries,
                });
            }
        }
        return bindGroups;
    };
    WebGPUCacheBindGroups.prototype.clearTextureEntries = function (textureId) {
        var textureEntries = WebGPUCacheBindGroups._CacheTextures[textureId];
        if (textureEntries) {
            for (var i = 0; i < textureEntries.length; ++i) {
                var node = textureEntries[i];
                this._clearTextureNode(node, textureId.toString());
                delete textureEntries[i].values[textureId];
            }
            delete WebGPUCacheBindGroups._CacheTextures[textureId];
        }
    };
    WebGPUCacheBindGroups.prototype._clearTextureNode = function (node, excludedId) {
        for (var id in node.values) {
            if (id !== excludedId) {
                this._clearTextureNode(node.values[id], excludedId);
                var entries = WebGPUCacheBindGroups._CacheTextures[id];
                if (entries) {
                    for (var i = 0; i < entries.length; ++i) {
                        if (entries[i] === node) {
                            entries.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }
    };
    WebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;
    WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;
    WebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();
    WebGPUCacheBindGroups._CacheTextures = {};
    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;
    return WebGPUCacheBindGroups;
}());
export { WebGPUCacheBindGroups };
//# sourceMappingURL=webgpuCacheBindGroups.js.map