/** @hidden */
var WebGPUMaterialContext = /** @class */ (function () {
    function WebGPUMaterialContext(cachBindGroups) {
        this._cacheBindGroups = cachBindGroups;
        this.samplers = {};
        this.textures = {};
        this.uniqueId = WebGPUMaterialContext._Counter++;
    }
    WebGPUMaterialContext.prototype.setTexture = function (name, internalTexture) {
        var textureCache = this.textures[name];
        if (!textureCache) {
            return false;
        }
        var curTexture = textureCache.texture;
        if (curTexture !== null && curTexture === internalTexture &&
            (textureCache.wrapU !== internalTexture._cachedWrapU || textureCache.wrapV !== internalTexture._cachedWrapV || textureCache.wrapR !== internalTexture._cachedWrapR ||
                textureCache.anisotropicFilteringLevel !== internalTexture._cachedAnisotropicFilteringLevel || textureCache.samplingMode !== internalTexture.samplingMode)) {
            // the sampler used to sample the texture must be updated, so we need to clear the bind group cache entries that are using
            // this texture so that the bind groups are re-created with the right sampler
            textureCache.wrapU = internalTexture._cachedWrapU;
            textureCache.wrapV = internalTexture._cachedWrapV;
            textureCache.wrapR = internalTexture._cachedWrapR;
            textureCache.anisotropicFilteringLevel = internalTexture._cachedAnisotropicFilteringLevel;
            textureCache.samplingMode = internalTexture.samplingMode;
            this._cacheBindGroups.clearTextureEntries(curTexture.uniqueId);
        }
        textureCache.texture = internalTexture;
        return true;
    };
    WebGPUMaterialContext._Counter = 0;
    return WebGPUMaterialContext;
}());
export { WebGPUMaterialContext };
//# sourceMappingURL=webgpuMaterialContext.js.map