import { __assign } from "tslib";
import * as WebGPUConstants from './webgpuConstants';
import { WebGPUTextureHelper } from "./webgpuTextureHelper";
var filterToBits = [
    0 | 0 << 1 | 0 << 2,
    0 | 0 << 1 | 0 << 2,
    1 | 1 << 1 | 0 << 2,
    1 | 1 << 1 | 1 << 2,
    0 | 0 << 1 | 0 << 2,
    0 | 1 << 1 | 0 << 2,
    0 | 1 << 1 | 1 << 2,
    0 | 1 << 1 | 0 << 2,
    0 | 0 << 1 | 1 << 2,
    1 | 0 << 1 | 0 << 2,
    1 | 0 << 1 | 1 << 2,
    1 | 1 << 1 | 0 << 2,
    1 | 0 << 1 | 0 << 2, // TEXTURE_LINEAR_NEAREST
];
// subtract 0x01FF from the comparison function value before indexing this array!
var comparisonFunctionToBits = [
    0 << 3 | 0 << 4 | 0 << 5 | 0 << 6,
    0 << 3 | 0 << 4 | 0 << 5 | 1 << 6,
    0 << 3 | 0 << 4 | 1 << 5 | 0 << 6,
    0 << 3 | 0 << 4 | 1 << 5 | 1 << 6,
    0 << 3 | 1 << 4 | 0 << 5 | 0 << 6,
    0 << 3 | 1 << 4 | 0 << 5 | 1 << 6,
    0 << 3 | 1 << 4 | 1 << 5 | 0 << 6,
    0 << 3 | 1 << 4 | 1 << 5 | 1 << 6,
    1 << 3 | 0 << 4 | 0 << 5 | 0 << 6, // ALWAYS
];
var filterNoMipToBits = [
    0 << 7,
    1 << 7,
    1 << 7,
    0 << 7,
    0 << 7,
    0 << 7,
    0 << 7,
    1 << 7,
    0 << 7,
    0 << 7,
    0 << 7,
    0 << 7,
    1 << 7, // TEXTURE_LINEAR_NEAREST
];
/** @hidden */
var WebGPUCacheSampler = /** @class */ (function () {
    function WebGPUCacheSampler(device) {
        this._samplers = {};
        this._device = device;
        this.disabled = false;
    }
    WebGPUCacheSampler._GetSamplerHashCode = function (texture) {
        var _a, _b, _c, _d;
        var code = filterToBits[texture.samplingMode] +
            comparisonFunctionToBits[(texture._comparisonFunction || 0x0202) - 0x0200 + 1] +
            filterNoMipToBits[texture.samplingMode] + // handle the lodMinClamp = lodMaxClamp = 0 case when no filter used for mip mapping
            (((_a = texture._cachedWrapU) !== null && _a !== void 0 ? _a : 1) << 8) +
            (((_b = texture._cachedWrapV) !== null && _b !== void 0 ? _b : 1) << 10) +
            (((_c = texture._cachedWrapR) !== null && _c !== void 0 ? _c : 1) << 12) +
            ((texture.generateMipMaps ? 1 : 0) << 14) + // need to factor this in because _getSamplerFilterDescriptor depends on samplingMode AND generateMipMaps!
            (((_d = texture._cachedAnisotropicFilteringLevel) !== null && _d !== void 0 ? _d : 1) << 15);
        return code;
    };
    WebGPUCacheSampler._GetSamplerFilterDescriptor = function (internalTexture, anisotropy) {
        var magFilter, minFilter, mipmapFilter, lodMinClamp, lodMaxClamp;
        var useMipMaps = internalTexture.generateMipMaps;
        switch (internalTexture.samplingMode) {
            case 11:
                magFilter = WebGPUConstants.FilterMode.Linear;
                minFilter = WebGPUConstants.FilterMode.Linear;
                mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                if (!useMipMaps) {
                    lodMinClamp = lodMaxClamp = 0;
                }
                break;
            case 3:
            case 3:
                magFilter = WebGPUConstants.FilterMode.Linear;
                minFilter = WebGPUConstants.FilterMode.Linear;
                if (!useMipMaps) {
                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                    lodMinClamp = lodMaxClamp = 0;
                }
                else {
                    mipmapFilter = WebGPUConstants.FilterMode.Linear;
                }
                break;
            case 8:
                magFilter = WebGPUConstants.FilterMode.Nearest;
                minFilter = WebGPUConstants.FilterMode.Nearest;
                if (!useMipMaps) {
                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                    lodMinClamp = lodMaxClamp = 0;
                }
                else {
                    mipmapFilter = WebGPUConstants.FilterMode.Linear;
                }
                break;
            case 4:
                magFilter = WebGPUConstants.FilterMode.Nearest;
                minFilter = WebGPUConstants.FilterMode.Nearest;
                mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                if (!useMipMaps) {
                    lodMinClamp = lodMaxClamp = 0;
                }
                break;
            case 5:
                magFilter = WebGPUConstants.FilterMode.Nearest;
                minFilter = WebGPUConstants.FilterMode.Linear;
                mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                if (!useMipMaps) {
                    lodMinClamp = lodMaxClamp = 0;
                }
                break;
            case 6:
                magFilter = WebGPUConstants.FilterMode.Nearest;
                minFilter = WebGPUConstants.FilterMode.Linear;
                if (!useMipMaps) {
                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                    lodMinClamp = lodMaxClamp = 0;
                }
                else {
                    mipmapFilter = WebGPUConstants.FilterMode.Linear;
                }
                break;
            case 7:
                magFilter = WebGPUConstants.FilterMode.Nearest;
                minFilter = WebGPUConstants.FilterMode.Linear;
                mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                lodMinClamp = lodMaxClamp = 0;
                break;
            case 1:
            case 1:
                magFilter = WebGPUConstants.FilterMode.Nearest;
                minFilter = WebGPUConstants.FilterMode.Nearest;
                mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                lodMinClamp = lodMaxClamp = 0;
                break;
            case 9:
                magFilter = WebGPUConstants.FilterMode.Linear;
                minFilter = WebGPUConstants.FilterMode.Nearest;
                mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                if (!useMipMaps) {
                    lodMinClamp = lodMaxClamp = 0;
                }
                break;
            case 10:
                magFilter = WebGPUConstants.FilterMode.Linear;
                minFilter = WebGPUConstants.FilterMode.Nearest;
                if (!useMipMaps) {
                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                    lodMinClamp = lodMaxClamp = 0;
                }
                else {
                    mipmapFilter = WebGPUConstants.FilterMode.Linear;
                }
                break;
            case 2:
            case 2:
                magFilter = WebGPUConstants.FilterMode.Linear;
                minFilter = WebGPUConstants.FilterMode.Linear;
                mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                lodMinClamp = lodMaxClamp = 0;
                break;
            case 12:
                magFilter = WebGPUConstants.FilterMode.Linear;
                minFilter = WebGPUConstants.FilterMode.Nearest;
                mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                lodMinClamp = lodMaxClamp = 0;
                break;
            default:
                magFilter = WebGPUConstants.FilterMode.Nearest;
                minFilter = WebGPUConstants.FilterMode.Nearest;
                mipmapFilter = WebGPUConstants.FilterMode.Nearest;
                lodMinClamp = lodMaxClamp = 0;
                break;
        }
        if (anisotropy > 1 && (lodMinClamp !== 0 || lodMaxClamp !== 0)) {
            return {
                magFilter: WebGPUConstants.FilterMode.Linear,
                minFilter: WebGPUConstants.FilterMode.Linear,
                mipmapFilter: WebGPUConstants.FilterMode.Linear,
                anisotropyEnabled: true,
            };
        }
        return {
            magFilter: magFilter,
            minFilter: minFilter,
            mipmapFilter: mipmapFilter,
            lodMinClamp: lodMinClamp,
            lodMaxClamp: lodMaxClamp,
        };
    };
    WebGPUCacheSampler._GetWrappingMode = function (mode) {
        switch (mode) {
            case 1:
                return WebGPUConstants.AddressMode.Repeat;
            case 0:
                return WebGPUConstants.AddressMode.ClampToEdge;
            case 2:
                return WebGPUConstants.AddressMode.MirrorRepeat;
        }
        return WebGPUConstants.AddressMode.Repeat;
    };
    WebGPUCacheSampler._GetSamplerWrappingDescriptor = function (internalTexture) {
        return {
            addressModeU: this._GetWrappingMode(internalTexture._cachedWrapU),
            addressModeV: this._GetWrappingMode(internalTexture._cachedWrapV),
            addressModeW: this._GetWrappingMode(internalTexture._cachedWrapR),
        };
    };
    WebGPUCacheSampler._GetSamplerDescriptor = function (internalTexture) {
        var _a;
        var anisotropy = internalTexture.generateMipMaps ? ((_a = internalTexture._cachedAnisotropicFilteringLevel) !== null && _a !== void 0 ? _a : 1) : 1;
        var filterDescriptor = this._GetSamplerFilterDescriptor(internalTexture, anisotropy);
        return __assign(__assign(__assign({}, filterDescriptor), this._GetSamplerWrappingDescriptor(internalTexture)), { compare: internalTexture._comparisonFunction ? WebGPUTextureHelper.GetCompareFunction(internalTexture._comparisonFunction) : undefined, maxAnisotropy: filterDescriptor.anisotropyEnabled ? anisotropy : 1 });
    };
    WebGPUCacheSampler.prototype.getSampler = function (internalTexture, bypassCache) {
        if (bypassCache === void 0) { bypassCache = false; }
        if (this.disabled) {
            return this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(internalTexture));
        }
        var hash = bypassCache ? 0 : WebGPUCacheSampler._GetSamplerHashCode(internalTexture);
        var sampler = bypassCache ? undefined : this._samplers[hash];
        if (!sampler) {
            sampler = this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(internalTexture));
            if (!bypassCache) {
                this._samplers[hash] = sampler;
            }
        }
        return sampler;
    };
    return WebGPUCacheSampler;
}());
export { WebGPUCacheSampler };
//# sourceMappingURL=webgpuCacheSampler.js.map