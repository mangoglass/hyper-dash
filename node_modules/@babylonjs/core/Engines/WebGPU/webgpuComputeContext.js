import { Logger } from "../../Misc/logger";
import { ComputeBindingType } from "../Extensions/engine.computeShader";
import * as WebGPUConstants from './webgpuConstants';
/** @hidden */
var WebGPUComputeContext = /** @class */ (function () {
    function WebGPUComputeContext(device, cacheSampler) {
        this._device = device;
        this._cacheSampler = cacheSampler;
        this.uniqueId = WebGPUComputeContext._Counter++;
        this.clear();
    }
    WebGPUComputeContext.prototype.getBindGroups = function (bindings, computePipeline, bindingsMapping) {
        if (!bindingsMapping) {
            throw new Error("WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!");
        }
        if (this._bindGroups.length === 0) {
            var bindGroupEntries = [];
            for (var key in bindings) {
                var binding = bindings[key], location_1 = bindingsMapping[key], group = location_1.group, index = location_1.binding, type = binding.type, object = binding.object;
                var entries = bindGroupEntries[group];
                if (!entries) {
                    entries = bindGroupEntries[group] = [];
                }
                switch (type) {
                    case ComputeBindingType.Texture: {
                        var texture = object;
                        var hardwareTexture = texture._texture._hardwareTexture;
                        entries.push({
                            binding: index - 1,
                            resource: this._cacheSampler.getSampler(texture._texture),
                        });
                        entries.push({
                            binding: index,
                            resource: hardwareTexture.view,
                        });
                        break;
                    }
                    case ComputeBindingType.StorageTexture: {
                        var texture = object;
                        var hardwareTexture = texture._texture._hardwareTexture;
                        if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.Storage) === 0) {
                            Logger.Error("computeDispatch: The texture (name=" + texture.name + ", uniqueId=" + texture.uniqueId + ") is not a storage texture!", 50);
                        }
                        entries.push({
                            binding: index,
                            resource: hardwareTexture.view,
                        });
                        break;
                    }
                    case ComputeBindingType.UniformBuffer: {
                        var buffer = object;
                        var dataBuffer = buffer.getBuffer();
                        var webgpuBuffer = dataBuffer.underlyingResource;
                        entries.push({
                            binding: index,
                            resource: {
                                buffer: webgpuBuffer,
                                offset: 0,
                                size: dataBuffer.capacity,
                            }
                        });
                        break;
                    }
                    case ComputeBindingType.StorageBuffer: {
                        var buffer = object;
                        var dataBuffer = buffer.getBuffer();
                        var webgpuBuffer = dataBuffer.underlyingResource;
                        entries.push({
                            binding: index,
                            resource: {
                                buffer: webgpuBuffer,
                                offset: 0,
                                size: dataBuffer.capacity,
                            }
                        });
                        break;
                    }
                }
            }
            for (var i = 0; i < bindGroupEntries.length; ++i) {
                var entries = bindGroupEntries[i];
                if (!entries) {
                    this._bindGroups[i] = undefined;
                    continue;
                }
                this._bindGroups[i] = this._device.createBindGroup({
                    layout: computePipeline.getBindGroupLayout(i),
                    entries: entries,
                });
            }
            this._bindGroups.length = bindGroupEntries.length;
        }
        return this._bindGroups;
    };
    WebGPUComputeContext.prototype.clear = function () {
        this._bindGroups = [];
    };
    WebGPUComputeContext._Counter = 0;
    return WebGPUComputeContext;
}());
export { WebGPUComputeContext };
//# sourceMappingURL=webgpuComputeContext.js.map