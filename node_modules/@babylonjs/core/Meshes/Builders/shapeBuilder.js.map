{"version":3,"file":"shapeBuilder.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Builders/shapeBuilder.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,OAAO,EAAE,UAAU,EAAW,MAAM,EAAE,MAAM,yBAAyB,CAAC;AAC/E,OAAO,EAAE,IAAI,EAAwB,MAAM,SAAS,CAAC;AACrD,OAAO,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAChD,OAAO,EAAE,MAAM,EAAE,MAAM,uBAAuB,CAAC;AAE/C,IAAI,CAAC,YAAY,GAAG,UAAC,IAAY,EAAE,KAAgB,EAAE,IAAe,EAAE,KAAa,EAAE,QAAgB,EAAE,GAAW,EAAE,KAA6B,EAAE,SAAmB,EAAE,eAAwB,EAAE,QAAe;IAA7F,sBAAA,EAAA,YAA6B;IAC7I,IAAM,OAAO,GAAG;QACZ,KAAK,EAAE,KAAK;QACZ,IAAI,EAAE,IAAI;QACV,KAAK,EAAE,KAAK;QACZ,QAAQ,EAAE,QAAQ;QAClB,GAAG,EAAE,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM;QACvC,eAAe,EAAE,eAAe;QAChC,QAAQ,EAAE,QAAQ;QAClB,SAAS,EAAE,SAAS;KACvB,CAAC;IAEF,OAAO,YAAY,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AAC3D,CAAC,CAAC;AAEF,IAAI,CAAC,kBAAkB,GAAG,UACtB,IAAY,EACZ,KAAgB,EAChB,IAAe,EACf,aAAkE,EAClE,gBAAqE,EACrE,gBAAyB,EACzB,eAAwB,EACxB,GAAW,EACX,KAAY,EACZ,SAAmB,EACnB,eAAwB,EACxB,QAAe;IAEf,IAAM,OAAO,GAAG;QACZ,KAAK,EAAE,KAAK;QACZ,IAAI,EAAE,IAAI;QACV,aAAa,EAAE,aAAa;QAC5B,gBAAgB,EAAE,gBAAgB;QAClC,gBAAgB,EAAE,gBAAgB;QAClC,eAAe,EAAE,eAAe;QAChC,GAAG,EAAE,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM;QACvC,eAAe,EAAE,eAAe;QAChC,QAAQ,EAAE,QAAQ;QAClB,SAAS,EAAE,SAAS;KACvB,CAAC;IAEF,OAAO,YAAY,CAAC,kBAAkB,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AACjE,CAAC,CAAC;AAEF;;GAEG;AACH;IAAA;IAuOA,CAAC;IAtOG;;;;;;;;;;;;;;;;;;;OAmBG;IACW,yBAAY,GAA1B,UACI,IAAY,EACZ,OAA0N,EAC1N,KAA6B;QAA7B,sBAAA,EAAA,YAA6B;QAE7B,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;QAC1B,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;QAC5B,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,IAAI,CAAC,CAAC;QACjC,IAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,CAAC,CAAC;QACvC,IAAM,GAAG,GAAG,OAAO,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC;QAC/D,IAAM,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACpC,IAAM,eAAe,GAAG,IAAI,CAAC,0BAA0B,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;QACjF,IAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,IAAI,CAAC;QAC1C,IAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,KAAK,CAAC;QAE3C,OAAO,YAAY,CAAC,oBAAoB,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,eAAe,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,QAAQ,IAAI,IAAI,EAAE,OAAO,CAAC,OAAO,IAAI,IAAI,CAAC,CAAC;IAChP,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;OAyBG;IACW,+BAAkB,GAAhC,UACI,IAAY,EACZ,OAcC,EACD,KAA6B;QAA7B,sBAAA,EAAA,YAA6B;QAE7B,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;QAC1B,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;QAC5B,IAAM,aAAa,GACf,OAAO,CAAC,aAAa;YACrB,CAAC;gBACG,OAAO,CAAC,CAAC;YACb,CAAC,CAAC,CAAC;QACP,IAAM,gBAAgB,GAClB,OAAO,CAAC,gBAAgB;YACxB,CAAC;gBACG,OAAO,CAAC,CAAC;YACb,CAAC,CAAC,CAAC;QACP,IAAM,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,IAAI,KAAK,CAAC;QAC3D,IAAM,eAAe,GAAG,OAAO,CAAC,eAAe,IAAI,KAAK,CAAC;QACzD,IAAM,GAAG,GAAG,OAAO,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC;QAC/D,IAAM,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACpC,IAAM,eAAe,GAAG,IAAI,CAAC,0BAA0B,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;QACjF,IAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;QAClC,IAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,KAAK,CAAC;QAC3C,OAAO,YAAY,CAAC,oBAAoB,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,aAAa,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,eAAe,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,eAAe,EAAE,QAAQ,IAAI,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,QAAQ,IAAI,IAAI,EAAE,OAAO,CAAC,OAAO,IAAI,IAAI,CAAC,CAAC;IAC5R,CAAC;IAEc,iCAAoB,GAAnC,UACI,IAAY,EACZ,KAAgB,EAChB,KAAgB,EAChB,KAAuB,EACvB,QAA0B,EAC1B,aAAkE,EAClE,cAAmE,EACnE,IAAa,EACb,IAAa,EACb,GAAW,EACX,MAAe,EACf,KAAsB,EACtB,MAAe,EACf,IAAY,EACZ,QAAwB,EACxB,QAAiB,EACjB,QAA2B,EAC3B,OAA0B;QAE1B,qBAAqB;QACrB,IAAM,kBAAkB,GAAG,UACvB,KAAgB,EAChB,KAAgB,EAChB,MAAc,EACd,UAAuB,EACvB,KAAuB,EACvB,QAA0B,EAC1B,aAAkE,EAClE,cAAmE,EACnE,GAAW,EACX,MAAe;YAEf,IAAM,QAAQ,GAAG,MAAM,CAAC,WAAW,EAAE,CAAC;YACtC,IAAM,OAAO,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;YACpC,IAAM,SAAS,GAAG,MAAM,CAAC,YAAY,EAAE,CAAC;YACxC,IAAM,SAAS,GAAG,MAAM,CAAC,YAAY,EAAE,CAAC;YAExC,IAAI,KAAK,GAAG,CAAC,CAAC;YACd,IAAM,WAAW,GAAG;gBAChB,OAAO,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACtC,CAAC,CAAC;YACF,IAAM,cAAc,GAAG;gBACnB,OAAO,QAAQ,KAAK,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;YAC5C,CAAC,CAAC;YACF,IAAM,MAAM,GAA8C,MAAM,IAAI,cAAc,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,cAAc,CAAC;YACrH,IAAM,GAAG,GAA8C,MAAM,IAAI,aAAa,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,WAAW,CAAC;YAC7G,IAAI,KAAK,GAAG,GAAG,KAAK,IAAI,CAAC,MAAM,IAAI,GAAG,KAAK,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAChE,IAAM,cAAc,GAAW,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAEpD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACnC,IAAM,SAAS,GAAG,IAAI,KAAK,EAAW,CAAC;gBACvC,IAAM,SAAS,GAAG,MAAM,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1C,IAAM,UAAU,GAAG,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;gBACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACnC,MAAM,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,cAAc,CAAC,CAAC;oBAC7D,IAAM,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACnH,IAAM,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;oBAC7D,OAAO,CAAC,yBAAyB,CAAC,MAAM,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;oBACnE,OAAO,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;oBACtD,SAAS,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC;iBAC1B;gBACD,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC;gBAC9B,KAAK,IAAI,SAAS,CAAC;gBACnB,KAAK,EAAE,CAAC;aACX;YACD,MAAM;YACN,IAAM,OAAO,GAAG,UAAC,SAAoB;gBACjC,IAAM,QAAQ,GAAG,KAAK,EAAW,CAAC;gBAClC,IAAM,UAAU,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;gBAClC,IAAI,CAAS,CAAC;gBACd,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACnC,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;iBACvC;gBACD,UAAU,CAAC,YAAY,CAAC,GAAG,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC;gBAChD,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACnC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;iBAC7B;gBACD,OAAO,QAAQ,CAAC;YACpB,CAAC,CAAC;YACF,QAAQ,GAAG,EAAE;gBACT,KAAK,IAAI,CAAC,MAAM;oBACZ,MAAM;gBACV,KAAK,IAAI,CAAC,SAAS;oBACf,UAAU,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;oBACvC,UAAU,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;oBAC9B,MAAM;gBACV,KAAK,IAAI,CAAC,OAAO;oBACb,UAAU,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;oBAC1C,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;oBACvD,MAAM;gBACV,KAAK,IAAI,CAAC,OAAO;oBACb,UAAU,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;oBACvC,UAAU,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;oBAC9B,UAAU,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;oBAC1C,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;oBACvD,MAAM;gBACV;oBACI,MAAM;aACb;YACD,OAAO,UAAU,CAAC;QACtB,CAAC,CAAC;QACF,IAAI,MAAM,CAAC;QACX,IAAI,SAAS,CAAC;QACd,IAAI,QAAQ,EAAE;YACV,kBAAkB;YAClB,IAAI,OAAO,GAAG,QAAQ,CAAC,oBAAqB,CAAC;YAC7C,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACtC,SAAS,GAAG,kBAAkB,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,SAAS,EAAE,KAAK,EAAE,QAAQ,EAAE,aAAa,EAAE,cAAc,EAAE,OAAO,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;YACrJ,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,KAAK,IAAI,SAAS,EAAE,KAAK,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;YAErG,OAAO,QAAQ,CAAC;SACnB;QACD,0BAA0B;QAC1B,MAAM,GAAQ,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC;QAChC,IAAM,aAAa,GAAG,IAAI,KAAK,EAAkB,CAAC;QAClD,GAAG,GAAG,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QACnC,SAAS,GAAG,kBAAkB,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,aAAa,EAAE,KAAK,EAAE,QAAQ,EAAE,aAAa,EAAE,cAAc,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;QACjI,IAAM,eAAe,GAAG,aAAa,CAAC,YAAY,CAAC,IAAI,EAAE,EAAE,SAAS,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,IAAI,SAAS,EAAE,OAAO,EAAE,OAAO,IAAI,SAAS,EAAE,EAAE,KAAK,CAAC,CAAC;QAC3P,eAAe,CAAC,oBAAqB,CAAC,SAAS,GAAG,SAAS,CAAC;QAC5D,eAAe,CAAC,oBAAqB,CAAC,MAAM,GAAG,MAAM,CAAC;QACtD,eAAe,CAAC,oBAAqB,CAAC,GAAG,GAAG,GAAG,CAAC;QAEhD,OAAO,eAAe,CAAC;IAC3B,CAAC;IACL,mBAAC;AAAD,CAAC,AAvOD,IAuOC","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3, TmpVectors, Vector4, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { RibbonBuilder } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\nMesh.ExtrudeShape = (name: string, shape: Vector3[], path: Vector3[], scale: number, rotation: number, cap: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ShapeBuilder.ExtrudeShape(name, options, scene);\r\n};\r\n\r\nMesh.ExtrudeShapeCustom = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotationFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    ribbonCloseArray: boolean,\r\n    ribbonClosePath: boolean,\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ShapeBuilder.ExtrudeShapeCustom(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class ShapeBuilder {\r\n    /**\r\n     * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n     * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    public static ExtrudeShape(\r\n        name: string,\r\n        options: { shape: Vector3[]; path: Vector3[]; scale?: number; rotation?: number; cap?: number; updatable?: boolean; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4; instance?: Mesh; invertUV?: boolean },\r\n        scene: Nullable<Scene> = null\r\n    ): Mesh {\r\n        const path = options.path;\r\n        const shape = options.shape;\r\n        const scale = options.scale || 1;\r\n        const rotation = options.rotation || 0;\r\n        const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n        const updatable = options.updatable;\r\n        const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        const instance = options.instance || null;\r\n        const invertUV = options.invertUV || false;\r\n\r\n        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, false, false, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);\r\n    }\r\n\r\n    /**\r\n     * Creates an custom extruded shape mesh.\r\n     * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n     * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n     * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n     * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n     * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`\r\n     * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the custom extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    public static ExtrudeShapeCustom(\r\n        name: string,\r\n        options: {\r\n            shape: Vector3[];\r\n            path: Vector3[];\r\n            scaleFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n            rotationFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n            ribbonCloseArray?: boolean;\r\n            ribbonClosePath?: boolean;\r\n            cap?: number;\r\n            updatable?: boolean;\r\n            sideOrientation?: number;\r\n            frontUVs?: Vector4;\r\n            backUVs?: Vector4;\r\n            instance?: Mesh;\r\n            invertUV?: boolean;\r\n        },\r\n        scene: Nullable<Scene> = null\r\n    ): Mesh {\r\n        const path = options.path;\r\n        const shape = options.shape;\r\n        const scaleFunction =\r\n            options.scaleFunction ||\r\n            (() => {\r\n                return 1;\r\n            });\r\n        const rotationFunction =\r\n            options.rotationFunction ||\r\n            (() => {\r\n                return 0;\r\n            });\r\n        const ribbonCloseArray = options.ribbonCloseArray || false;\r\n        const ribbonClosePath = options.ribbonClosePath || false;\r\n        const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n        const updatable = options.updatable;\r\n        const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        const instance = options.instance;\r\n        const invertUV = options.invertUV || false;\r\n        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);\r\n    }\r\n\r\n    private static _ExtrudeShapeGeneric(\r\n        name: string,\r\n        shape: Vector3[],\r\n        curve: Vector3[],\r\n        scale: Nullable<number>,\r\n        rotation: Nullable<number>,\r\n        scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        rbCA: boolean,\r\n        rbCP: boolean,\r\n        cap: number,\r\n        custom: boolean,\r\n        scene: Nullable<Scene>,\r\n        updtbl: boolean,\r\n        side: number,\r\n        instance: Nullable<Mesh>,\r\n        invertUV: boolean,\r\n        frontUVs: Nullable<Vector4>,\r\n        backUVs: Nullable<Vector4>\r\n    ): Mesh {\r\n        // extrusion geometry\r\n        const extrusionPathArray = (\r\n            shape: Vector3[],\r\n            curve: Vector3[],\r\n            path3D: Path3D,\r\n            shapePaths: Vector3[][],\r\n            scale: Nullable<number>,\r\n            rotation: Nullable<number>,\r\n            scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n            rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n            cap: number,\r\n            custom: boolean\r\n        ) => {\r\n            const tangents = path3D.getTangents();\r\n            const normals = path3D.getNormals();\r\n            const binormals = path3D.getBinormals();\r\n            const distances = path3D.getDistances();\r\n\r\n            let angle = 0;\r\n            const returnScale = () => {\r\n                return scale !== null ? scale : 1;\r\n            };\r\n            const returnRotation = () => {\r\n                return rotation !== null ? rotation : 0;\r\n            };\r\n            const rotate: { (i: number, distance: number): number } = custom && rotateFunction ? rotateFunction : returnRotation;\r\n            const scl: { (i: number, distance: number): number } = custom && scaleFunction ? scaleFunction : returnScale;\r\n            let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n            const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n\r\n            for (let i = 0; i < curve.length; i++) {\r\n                const shapePath = new Array<Vector3>();\r\n                const angleStep = rotate(i, distances[i]);\r\n                const scaleRatio = scl(i, distances[i]);\r\n                for (let p = 0; p < shape.length; p++) {\r\n                    Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n                    const planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\r\n                    const rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();\r\n                    Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                    rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                    shapePath[p] = rotated;\r\n                }\r\n                shapePaths[index] = shapePath;\r\n                angle += angleStep;\r\n                index++;\r\n            }\r\n            // cap\r\n            const capPath = (shapePath: Vector3[]) => {\r\n                const pointCap = Array<Vector3>();\r\n                const barycenter = Vector3.Zero();\r\n                let i: number;\r\n                for (i = 0; i < shapePath.length; i++) {\r\n                    barycenter.addInPlace(shapePath[i]);\r\n                }\r\n                barycenter.scaleInPlace(1.0 / shapePath.length);\r\n                for (i = 0; i < shapePath.length; i++) {\r\n                    pointCap.push(barycenter);\r\n                }\r\n                return pointCap;\r\n            };\r\n            switch (cap) {\r\n                case Mesh.NO_CAP:\r\n                    break;\r\n                case Mesh.CAP_START:\r\n                    shapePaths[0] = capPath(shapePaths[2]);\r\n                    shapePaths[1] = shapePaths[2];\r\n                    break;\r\n                case Mesh.CAP_END:\r\n                    shapePaths[index] = shapePaths[index - 1];\r\n                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                    break;\r\n                case Mesh.CAP_ALL:\r\n                    shapePaths[0] = capPath(shapePaths[2]);\r\n                    shapePaths[1] = shapePaths[2];\r\n                    shapePaths[index] = shapePaths[index - 1];\r\n                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            return shapePaths;\r\n        };\r\n        let path3D;\r\n        let pathArray;\r\n        if (instance) {\r\n            // instance update\r\n            let storage = instance._creationDataStorage!;\r\n            path3D = storage.path3D.update(curve);\r\n            pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);\r\n            instance = Mesh.CreateRibbon(\"\", pathArray, false, false, 0, scene || undefined, false, 0, instance);\r\n\r\n            return instance;\r\n        }\r\n        // extruded shape creation\r\n        path3D = <any>new Path3D(curve);\r\n        const newShapePaths = new Array<Array<Vector3>>();\r\n        cap = cap < 0 || cap > 3 ? 0 : cap;\r\n        pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\r\n        const extrudedGeneric = RibbonBuilder.CreateRibbon(name, { pathArray: pathArray, closeArray: rbCA, closePath: rbCP, updatable: updtbl, sideOrientation: side, invertUV: invertUV, frontUVs: frontUVs || undefined, backUVs: backUVs || undefined }, scene);\r\n        extrudedGeneric._creationDataStorage!.pathArray = pathArray;\r\n        extrudedGeneric._creationDataStorage!.path3D = path3D;\r\n        extrudedGeneric._creationDataStorage!.cap = cap;\r\n\r\n        return extrudedGeneric;\r\n    }\r\n}\r\n"]}