{"version":3,"file":"KHR_materials_transmission.js","sourceRoot":"","sources":["../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"@babylonjs/core/types\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\nimport { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { GLTFLoader } from \"../glTFLoader\";\nimport { IKHRMaterialsTransmission } from 'babylonjs-gltf2interface';\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"@babylonjs/core/Materials/Textures/renderTargetTexture\";\nimport { Observable, Observer } from \"@babylonjs/core/Misc/observable\";\nimport { Constants } from \"@babylonjs/core/Engines/constants\";\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { Color4 } from \"@babylonjs/core/Maths/math.color\";\n\ninterface ITransmissionHelperHolder {\n    /**\n     * @hidden\n     */\n    _transmissionHelper: TransmissionHelper | undefined;\n}\n\ninterface ITransmissionHelperOptions {\n    /**\n     * The size of the render buffers (default: 1024)\n     */\n    renderSize: number;\n\n    /**\n     * The number of samples to use when generating the render target texture for opaque meshes (default: 4)\n     */\n    samples: number;\n\n    /**\n     * Scale to apply when selecting the LOD level to sample the refraction texture (default: 1)\n     */\n    lodGenerationScale: number;\n\n    /**\n     * Offset to apply when selecting the LOD level to sample the refraction texture (default: -4)\n     */\n    lodGenerationOffset: number;\n\n    /**\n     * Type of the refraction render target texture (default: TEXTURETYPE_HALF_FLOAT)\n     */\n    renderTargetTextureType: number;\n\n    /**\n     * Defines if the mipmaps for the refraction render target texture must be generated (default: true)\n     */\n    generateMipmaps: boolean;\n\n    /**\n     * Clear color of the opaque texture. If not provided, use the scene clear color (which will be converted to linear space).\n     * If provided, should be in linear space\n     */\n    clearColor?: Color4;\n}\n\n/**\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\n */\nclass TransmissionHelper {\n\n    /**\n     * Creates the default options for the helper.\n     */\n    private static _getDefaultOptions(): ITransmissionHelperOptions {\n        return {\n            renderSize: 1024,\n            samples: 4,\n            lodGenerationScale: 1,\n            lodGenerationOffset: -4,\n            renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\n            generateMipmaps: true,\n        };\n    }\n\n    /**\n     * Stores the creation options.\n     */\n    private readonly _scene: Scene & ITransmissionHelperHolder;\n\n    private _options: ITransmissionHelperOptions;\n\n    private _opaqueRenderTarget: Nullable<RenderTargetTexture> = null;\n    private _opaqueMeshesCache: AbstractMesh[] = [];\n    private _transparentMeshesCache: AbstractMesh[] = [];\n    private _materialObservers: { [id: string]: Nullable<Observer<AbstractMesh>> } = {};\n\n    /**\n     * This observable will be notified with any error during the creation of the environment,\n     * mainly texture creation errors.\n     */\n    public onErrorObservable: Observable<{ message?: string, exception?: any }>;\n\n    /**\n     * constructor\n     * @param options Defines the options we want to customize the helper\n     * @param scene The scene to add the material to\n     */\n    constructor(options: Partial<ITransmissionHelperOptions>, scene: Scene) {\n        this._options = {\n            ...TransmissionHelper._getDefaultOptions(),\n            ...options\n        };\n        this._scene = scene as any;\n        this._scene._transmissionHelper = this;\n\n        this.onErrorObservable = new Observable();\n        this._scene.onDisposeObservable.addOnce((scene) => {\n            this.dispose();\n        });\n\n        this._parseScene();\n        this._setupRenderTargets();\n    }\n\n    /**\n     * Updates the background according to the new options\n     * @param options\n     */\n    public updateOptions(options: Partial<ITransmissionHelperOptions>) {\n        // First check if any options are actually being changed. If not, exit.\n        const newValues = Object.keys(options).filter((key: string) => (this._options as any)[key] !== (options as any)[key]);\n        if (!newValues.length) {\n            return;\n        }\n\n        const newOptions = {\n            ...this._options,\n            ...options\n        };\n\n        const oldOptions = this._options;\n        this._options = newOptions;\n\n        // If size changes, recreate everything\n        if (newOptions.renderSize !== oldOptions.renderSize || newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType || newOptions.generateMipmaps !== oldOptions.generateMipmaps || !this._opaqueRenderTarget) {\n            this._setupRenderTargets();\n        } else {\n            this._opaqueRenderTarget.samples = newOptions.samples;\n            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\n            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\n        }\n    }\n\n    public getOpaqueTarget(): Nullable<Texture> {\n        return this._opaqueRenderTarget;\n    }\n\n    private shouldRenderAsTransmission(material: Nullable<Material>): boolean {\n        if (!material) {\n            return false;\n        }\n        if (material instanceof PBRMaterial && (material.subSurface.isRefractionEnabled)) {\n            return true;\n        }\n        return false;\n    }\n\n    private _addMesh(mesh: AbstractMesh): void {\n        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\n\n        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\n        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\n        Tools.SetImmediate(() => {\n            if (this.shouldRenderAsTransmission(mesh.material)) {\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\n                this._transparentMeshesCache.push(mesh);\n            } else {\n                this._opaqueMeshesCache.push(mesh);\n            }\n        });\n    }\n\n    private _removeMesh(mesh: AbstractMesh): void {\n        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\n        delete this._materialObservers[mesh.uniqueId];\n        let idx = this._transparentMeshesCache.indexOf(mesh);\n        if (idx !== -1) {\n            this._transparentMeshesCache.splice(idx, 1);\n        }\n        idx = this._opaqueMeshesCache.indexOf(mesh);\n        if (idx !== -1) {\n            this._opaqueMeshesCache.splice(idx, 1);\n        }\n    }\n\n    private _parseScene(): void {\n        this._scene.meshes.forEach(this._addMesh.bind(this));\n        // Listen for when a mesh is added to the scene and add it to our cache lists.\n        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\n        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\n        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\n    }\n\n    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\n    private _onMeshMaterialChanged(mesh: AbstractMesh) {\n        const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\n        const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\n\n        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\n        const useTransmission = this.shouldRenderAsTransmission(mesh.material);\n        if (useTransmission) {\n            if (mesh.material instanceof PBRMaterial) {\n                mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\n            }\n            if (opaqueIdx !== -1) {\n                this._opaqueMeshesCache.splice(opaqueIdx, 1);\n                this._transparentMeshesCache.push(mesh);\n            } else if (transparentIdx === -1) {\n                this._transparentMeshesCache.push(mesh);\n            }\n            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\n        } else {\n            if (transparentIdx !== -1) {\n                this._transparentMeshesCache.splice(transparentIdx, 1);\n                this._opaqueMeshesCache.push(mesh);\n            } else if (opaqueIdx === -1) {\n                this._opaqueMeshesCache.push(mesh);\n            }\n        }\n    }\n\n    /**\n     * Setup the render targets according to the specified options.\n     */\n    private _setupRenderTargets(): void {\n        if (this._opaqueRenderTarget) {\n            this._opaqueRenderTarget.dispose();\n        }\n        this._opaqueRenderTarget = new RenderTargetTexture(\"opaqueSceneTexture\", this._options.renderSize, this._scene, this._options.generateMipmaps, undefined, this._options.renderTargetTextureType);\n        this._opaqueRenderTarget.ignoreCameraViewport = true;\n        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\n        this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone();\n        this._opaqueRenderTarget.gammaSpace = false;\n        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\n        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\n        this._opaqueRenderTarget.samples = this._options.samples;\n\n        let sceneImageProcessingapplyByPostProcess: boolean;\n\n        let saveSceneEnvIntensity: number;\n        this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {\n            saveSceneEnvIntensity = this._scene.environmentIntensity;\n            this._scene.environmentIntensity = 1.0;\n            sceneImageProcessingapplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\n            if (!this._options.clearColor) {\n                this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor);\n            } else {\n                opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\n            }\n            this._scene.imageProcessingConfiguration.applyByPostProcess = true;\n        });\n        this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\n            this._scene.environmentIntensity = saveSceneEnvIntensity;\n            this._scene.imageProcessingConfiguration.applyByPostProcess = sceneImageProcessingapplyByPostProcess;\n        });\n\n        this._transparentMeshesCache.forEach((mesh: AbstractMesh) => {\n            if (this.shouldRenderAsTransmission(mesh.material)) {\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\n            }\n        });\n    }\n\n    /**\n     * Dispose all the elements created by the Helper.\n     */\n    public dispose(): void {\n        this._scene._transmissionHelper = undefined;\n        if (this._opaqueRenderTarget) {\n            this._opaqueRenderTarget.dispose();\n            this._opaqueRenderTarget = null;\n        }\n        this._transparentMeshesCache = [];\n        this._opaqueMeshesCache = [];\n    }\n}\n\nconst NAME = \"KHR_materials_transmission\";\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\n */\nexport class KHR_materials_transmission implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n    public order = 175;\n\n    private _loader: GLTFLoader;\n\n    /** @hidden */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n        if (this.enabled) {\n            loader.parent.transparencyAsCoverage = true;\n        }\n    }\n\n    /** @hidden */\n    public dispose() {\n        (this._loader as any) = null;\n    }\n\n    /** @hidden */\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsTransmission>(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n\n    private _loadTransparentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsTransmission): Promise<void> {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        let pbrMaterial = babylonMaterial as PBRMaterial;\n\n        // Enables \"refraction\" texture which represents transmitted light.\n        pbrMaterial.subSurface.isRefractionEnabled = true;\n\n        // Since this extension models thin-surface transmission only, we must make IOR = 1.0\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\n\n        // Albedo colour will tint transmission.\n        pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\n\n        if (extension.transmissionFactor !== undefined) {\n            pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\n            const scene = pbrMaterial.getScene() as unknown as ITransmissionHelperHolder;\n            if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\n                new TransmissionHelper({}, pbrMaterial.getScene());\n            }\n        } else {\n            pbrMaterial.subSurface.refractionIntensity = 0.0;\n            pbrMaterial.subSurface.isRefractionEnabled = false;\n            return Promise.resolve();\n        }\n\n        pbrMaterial.subSurface.minimumThickness = 0.0;\n        pbrMaterial.subSurface.maximumThickness = 0.0;\n        if (extension.transmissionTexture) {\n            (extension.transmissionTexture as ITextureInfo).nonColorData = true;\n            return this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, undefined)\n                .then((texture: BaseTexture) => {\n                    pbrMaterial.subSurface.refractionIntensityTexture = texture;\n                    pbrMaterial.subSurface.useGltfStyleTextures = true;\n                });\n        } else {\n            return Promise.resolve();\n        }\n    }\n}\n\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_transmission(loader));\n"]}